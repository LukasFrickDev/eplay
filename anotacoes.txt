1 - Projeto 6 - CONFIGURAÇÕES INICIAS E ESTRUTURAÇÃO

    1.1 - Configurações Iniciais

        Clonado repositorio ja com eslint, editorconfig e prettier já configurados
        npm i 
        npm i --save styled-components react-router-dom
        para corrigir formatação caso necessario - npx eslint --fix
        apagar arquivos que nao serao utilizados: App.css, index.css, App.test.tsx, logo.svg
        criar um styles.ts nas pasta src para criar regras css globais: 
        //////////////////////////////////////////////////////////////
            import styled,{ createGlobalStyle } from 'styled-components'

            export const colors = {
            branca: '#333',
            preto: '#111',
            cinza: '#EEEEEE',
            verde: '#10AC84'
            }

            const GlobalCss = createGlobalStyle`
            * {
                margin:0;
                padding: 0;
                box-sizing:border-box;
                font-family: Roboto, 'sans-serif'
            }

            body {
                background-color: ${colors.black};
                color: ${colors.white}
                padding-top: 40px;
            }
            `
            export const Container = styled.div`
                max-witdh: 1024px;
                witdh: 100%;
                margin: 0 auto;
            `

            export default GlobalCss
        ////////////////////////////////////////////////////////////
        apagar informações dentro de App.tsx que não vai utilizar e incluir o importação do GlobalCss
            function App() {
                return (
                    <>
                    <GlobalCss />
                    <div>Olá Mundo</div>
                    </>
                )
            }
        /////////////////////////////////////////////////////////////

    1.2 - Construção do Cabeçalho 

        criação da pasta assest em src para colocar imagens e ter a logo
        criar pasta components em src para cliar o componente Header/index.tsx  
        criar a constante Header generica e importar no App.tsx para verificar se funcionou.
        criar o styles.ts
        estilizar o cabeçalho normalmente por enquanto
        //////////////////////////////////////////////////////////////
        componentes/Header/index.tsx

        import * as S from './styles'
        import logo from '../../assets/images/logo.svg'
        import carrinho from '../../assets/images/carrinho.svg'

        const Header = () => (
        <S.HeaderBar>
            <div>
            <img src={logo} alt="EPLAY" />
            <nav>
                <S.Links>
                <S.LinkItem>
                    <a href="#">Categoria</a>
                </S.LinkItem>
                <S.LinkItem>
                    <a href="#">Novidades</a>
                </S.LinkItem>
                <S.LinkItem>
                    <a href="#">Promoções</a>
                </S.LinkItem>
                </S.Links>
            </nav>
            </div>
            <S.LinkCart href="#">
            0 - Produtos
            <img src={carrinho} alt="Carrinho" />
            </S.LinkCart>
        </S.HeaderBar>
        )

        export default Header
        /////////////////////////////////////////////////////////////////
        componentes/Header/styles.tsx
        import styled from 'styled-components'
        import { colors } from '../../styles'

        export const HeaderBar = styled.header`
            background-color: ${colors.gray};
            padding: 24px;
            border-radius: 16px;
            margin-bottom: 80px;
            display: flex;
            align-items: center;
            justify-content: space-between;

            a {
                color: ${colors.white};
                text-decoration: none;
                font-weight: bold;
            }

            div {
                display: flex;
                align-items: center;
            }
        `

        export const Links = styled.ul`
            display: flex;
            margin-left: 40px;
            `

        export const LinkItem = styled.li`
            margin-right: 16px;
            `

        export const LinkCart = styled.a`
            display: flex;

            align-items: center;
            img {
                margin-left: 16px;
            }
        `
        ////////////////////////////////////////////////////////////

    1.3 - Construção do Banner
        Criar um nova pasta em components chamada Banner incluindo index.tsx e styles.ts
        fazer as importações e exportações necessarias e testar, tambem com App.tsx
        usar a imagem de banner como div em vez de img e estilizar pelo styled-components usando style={{ backgroundImage: `url(${bannerImg})` }} para ter melhor controle sobre posicionamento e conteudo

        /////////////////////////////////////////////////////////////////
        componentes/Banner/index.tsx

        import * as S from './styles'
        import bannerImg from '../../assets/images/banner-homem-aranha.png'

        const Banner = () => (
        <S.Imagem style={{ backgroundImage: `url(${bannerImg})` }}>
            <div className="container">
            <S.Titulo>Marvel&apos;s Spider-Man: Miles Morales PS4 & PS5</S.Titulo>
            <S.Precos>
                De <span>R$250,00</span>
                <br />
                por apenas R$99,90
            </S.Precos>
            </div>
        </S.Imagem>
        )

        export default Banner
        ////////////////////////////////////////////////////////////////////
        componentes/Banner/styles.ts

        import styled from 'styled-components'

        export const Imagem = styled.div`
            width: 100%;
            height: 560px;
            display: block;
            background-repeat: no-repeat;
            background-size: cover;
            font-weight: bold;
            padding-top: 340px;
        `
        export const Titulo = styled.h2`
            font-size: 36px;
            max-width: 450px;
        `
        export const Precos = styled.p`
            font-size: 24px;
            margin-top: 24px;
            span {
                text-decoration: line-throught;
            }
        `

    1.4 - Componentização 1
        criar o componetização da Tag do banner e listagens de produtos
            - criar a tag no estilo de maior utilização e qual tiver diferença alterar como variação 
        
        //////////////////////////////////////////////////////////////
        Ao criar o const da Tag e ativar tipagem no container da tag é possivel notar que size não é reconhecido.
        Por isso deve importar a tipagem Props para o styles e incluir na div da const TagContainer

        indes.tsx:
        export type Props = {  
            size?: 'small' | 'big'
            children: string
        }

        const Tag = ({ children, size = 'small' }: Props) => (
            <S.TagContainer size={size}>{children}</S.TagContainer>
        )

        export default Tag 

        styles.ts:
        import styled from 'styled-components'
        import { colors } from '../../styles'

        import { Props } from '.'

        export const TagContainer = styled.div<Props>` <<<<<<----------
            background-color: ${colors.green};
            color: ${colors.white};
            padding: ${(props) => (props.size === 'big' ? '8px 16px' : '4px 6px')};           | Aqui foi feito uma função para verificar o size
            font-size: ${(props) => (props.size === 'big' ? '16px' : '10px')};                | se receber 'big' ira retornar um valor e se receber 'small' outro.
            font-weight: bold;
            border-radius: 8px;
            display: inline-block;
        `
        ////////////////////////////////////////////////////////////////////////////////////////////////////////

        Apos finalizar a configuração da primeira tag inculuir no componente do Banner:
        const Banner = () => (
            <S.Imagem style={{ backgroundImage: `url(${bannerImg})` }}>
                <div className="container">
                <Tag size="big">Destaque do Dia</Tag>   <<<<<<<================================
                <S.Titulo>Marvel&apos;s Spider-Man: Miles Morales PS4 & PS5</S.Titulo>
                <S.Precos>
                    De <span>R$250,00</span>
                    <br />
                    por apenas R$99,90
                </S.Precos>
                </div>
            </S.Imagem>
        )

        Para ajustar a estilização dessa tag em especifico no banner, acessar o styles.ts do Banner e fazer a seguinte alteração:

        export const Imagem = styled.div`
            width: 100%;
            height: 560px;
            display: block;
            background-repeat: no-repeat;
            background-size: cover;
            font-weight: bold;

            .container {
                position: relative;      <<<<< ativar position relative para movimentar a tag apenas dentro do banner
                padding-top: 340px;      <<<<< trazer padding para container
            }

            ${TagContainer} {            <<<<< forma de modificar uma Tag global por uma variação especifica para o componente
                position: absolute;      <<<<< position absolut para movimentar a tag conforme pedido abaixo
                top: 32px;               <<<<< posição de altura da Tag
            }
        `
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        Criando o componente Botao, aqui vamos criar ja tanto opção de botão quanto para botão de link.
        Primeiro ciramos a pasta em componente Botao/ index.ts e style.ts
        tivemos que criar a tipagem com as seguintes props, 'type''title''to''onClick''children' ja descrevendo a funlçao de cada no codigo
        como temos dois tipo de dados para receber ('button ou link') precisamos fazer um if na função de Button:
        
        INDEX.TSX
        import * as S from './styles'

        type Props = {
            type: 'button' | 'link' // tipo de dado
            title: string // titulo do dado
            to?: string // caminho
            onClick?: () => void // isso permite o recebeimneto de uma função que nao tem argumento e devolver nada
            children: string // texto do botao
        }

        const Button = ({ type, title, to, onClick, children }: Props) => {
            if (type === 'button') {
                return (
                <S.ButtonContainer type="button" title={title} onClick={onClick}>
                    {children}
                </S.ButtonContainer>
                )
        }

            return (
                <S.ButtonLink to={to as string} title={title}>
                {children}
                </S.ButtonLink>
            )
        }

        export default Button

        STYLE.TS
        import { styled } from 'styled-components'
        import { colors } from '../../styles'
        import { Link } from 'react-router-dom'

        export const ButtonContainer = styled.button`
            backgroud-color: transparent;
            color: ${colors.white};
            border: 2px solid ${colors.white};
            font-size: 16px;
            font-weight: bold;
            padding: 8px 16px;
            border-radius: 8px;

        `

        export const ButtonLink = styled(Link)`
            backgroud-color: transparent;
            color: ${colors.white};
            border: 2px solid ${colors.white};
            font-size: 16px;
            font-weight: bold;
            padding: 8px 16px;
            text-decoration: none;
            border-radius: 8px;

        `

        ** não esquecer de configurar o react-router-dom

        em src/App.tsx importar o createBrowserRouter, RouterProvider do react-router-dom e criar uma rota inicial temporaria apenas para banner

        const rotas = createBrowserRouter([       <<<<<< CRIAÇÃO DA ROTA TEMPORARIA PARA O BANNER
            {
                path: '/',
                element: <Banner />
            }
        ])

        function App() {
            return (
                <>
                <GlobalCss />
                <div className="container">
                    <Header />
                </div>
                <RouterProvider router={rotas} />    <<<<< ALTERAR BANNER PARA SEGUIR A ROTA CRIADA
                </>
            )
        }

        export default App

        /////////////////////////////////////////////////////////////////////////////////////////////////

        Finalizando a estilização e criação do componente Botao, vamos incluir no Banner
        
        Banner/INDEX.TSX
        import Button from '../Botao'
        const Banner = () => (
            <S.Imagem style={{ backgroundImage: `url(${bannerImg})` }}>
                <div className="container">
                <Tag size="big">Destaque do Dia</Tag>
                <div>                                                                       <<<<<< div foi incluida para estilziar o flexbox do botao com o texto
                    <S.Titulo>Marvel&apos;s Spider-Man: Miles Morales PS4 & PS5</S.Titulo>
                    <S.Precos>
                        De <span>R$250,00</span>
                        <br />
                        por apenas R$99,90
                    </S.Precos>
                </div>
                <Button                                              <<<<<<<< AQUI IMPORTAMOS O BOTÃO COM TODAS AS PROPRIEDADES NECESSARIAS PARA VISUALIZAR
                    type="link"
                    to="/produto"
                    title="Clique aqui para aproveitar essa oferta"
                >
                    Aproveitar
                </Button>
                </div>
            </S.Imagem>
        )

        Style.ts

        apenas modifou a classe .container para:
            .container {
                position: relative;
                padding-top: 340px;
                display: flex;
                justify-content: space-between;
                align-items: flex-end;
            }

    1.5 - Componentização 2 - Estilizar os Cards de Produtos - Part 1
        Criar um componente Produto - Nesse caso estamos criando apenas o container de produtos, nao o grid
        Para isso foi criada e components uma pasta Product com index.tsx e style.ts para estilização
        ainda com informações genericas apenas para visualização

        index.tsx
        import * as S from './styles'
        import Tag from '../Tag'
        import diabloImg from '../../assets/images/diablo.png'

        const Product = () => (
            <S.Card>
                <img src={diabloImg} />
                <S.Titulo>Nome Do Jogo</S.Titulo>
                <Tag>Categoria</Tag>
                <Tag>Windows</Tag>
                <S.Descricao>
                Lorem ipsum dolor sit amet consectetur adipisicing elit. Id dolor, laborum
                quae dicta odio assumenda repellat dolorem qui nostrum voluptas voluptates
                dolores. Earum delectus rem possimus porro illum maxime eaque!
                </S.Descricao>
            </S.Card>
        )

        export default Product

        style.ts
        import { styled } from 'styled-components'
        import { colors } from '../../styles'
        import { TagContainer } from '../Tag/styles'

        export const Card = styled.div`
            background-color: ${colors.gray};
            border-radius: 8px;
            padding: 8px;

            ${TagContainer} {
                margin-right: 8px;
            }
        `
        export const Titulo = styled.h3`
            font-size: 16px;
            font-weight: bold;
            display: block;
            margin-top: 16px;
            margin-bottom: 8px;
        `

        export const Descricao = styled.p`
            font-size: 14px;
            line-height: 22px;
            display: block;
            margin-top: 16px;
        `

        ///////////////////////////////////////////////////////////////////////////////////////

        Apos a estilização e configuração do componente de Produto, vamos criar o estilo de grid do mesmo, pois no site há algumas seções em grid
        Para isso vamos criar um novo componente de Lista de Produto.
        Criamos em components um pasta ProductList com index.tsx e style.ts

        index.tsx    
        import Product from '../Product'
        import * as S from './styles'
    
        type Props = {                               <<<<< CRIAMOS UMA TIPAGEM PARA VARIAÇÃO DE FUNDO E TITULO DA SEÇÃO
            title: string
            background: 'gray' | 'black'
        }

        const ProductList = ({ title, background }: Props) => (
            <S.Container>
                <div className="container">
                <h2>{title}</h2>    
                <S.List>                            <<<<<< CRIAMOS UMA UL PARA FAZER O GRID
                    <Product />
                    <Product />
                    <Product />
                    <Product />
                </S.List>
                </div>
            </S.Container>
        )

        export default ProductList


        style.ts
        import styled from 'styled-components'

        export const Container = styled.section`
            padding: 32px 0;
        `
        export const List = styled.ul`
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            column-gap: 24px;
            margin-top: 40px;
        `
        export const Title = styled.h2`
            font-size: 18px;
            font-weight: bold;
        `

        ////////////////////////////////////////////////////////////////////////////////////////

        Para visualizar a seção de forma correta com o componente grid e produtos precisamos altear o caminho 
        em App.tsx

        Trocar <Product> por <ProductList> e seus tipos incluidos: <ProductList title="Promoções" background="gray" />

        const rotas = createBrowserRouter([
            {
                path: '/',
                element: (
                <>
                    <Banner />
                    <ProductList title="Promoções" background="gray" />  <<<< APENAS ESSA ALTERAÇÃO
                </>
                )
            }
        ])

        Nessa caso é para chamar o ProductList e dentro desse componente chama os Produtos.

    1.6 - Componentização 3 - Estilizar os Cards de Produtos - Part 2 
        Aqui vamos usar array de strings para renderizar diferentes tags
        para criar a variação de seção e tags dos produtos começamos criando tipagem nos produtos
        com todas as informações que devemos receber como: titulo, categoria, sistema, descrição, infos e imagem
        Apos isso incluimos na const Product já organizado:

        Em src/Product/...

        index.tsx
        import * as S from './styles'
        import Tag from '../Tag'

        type Props = {
            title: string
            category: string
            system: string
            description: string
            infos: string[]
            image: string
        }

        const Product = ({
            title,
            category,
            system,
            description,
            infos,
            image
        }: Props) => (
            <S.Card>
                <img src={image} alt={title} />
                <S.Infos>
                {infos.map((info) => (                    <<<< essa função é para buscar todas as informações na array infos e retornar
                    <Tag key={info}>{info}</Tag>
                ))}
                </S.Infos>
                <S.Titulo>{title}</S.Titulo>
                <Tag>{category}</Tag>
                <Tag>{system}</Tag>
                <S.Descricao>{description}</S.Descricao>
            </S.Card>
        )

        export default Product

        style.ts

        Aqui vamos apenas adicionar position: relative em Card para as tag usarem esse container de referencia
        e criar a const Infos

        export const Card = styled.div`
            background-color: ${colors.gray};
            border-radius: 8px;
            padding: 8px;
            position: relative;

            ${TagContainer} {
                margin-right: 8px;
            }
        `
        export const Infos = styled.div`
            position: absolute;
            top: 16px;
            right: 16px;
        `

        Assim finalizamos a configuração e estilização das tag de cima dos cards dos produtos.

        /////////////////////////////////////////////////////////////////////////////////

        Agora vamos fazer a variação de background da seção gray e black e cards
        Primeiramente precisamos retornar os valores solicitados na tipagem que criamos anteriormente em Products
        que são: titulo, categoria, sistema, descrição, infos e imagem
        Também, no container retornamos o background 
        Em src/ProductList/...

        index.tsx
        import Product from '../Product'
        import * as S from './styles'
        import imageDir from '../../assets/images/diablo.png'

        export type Props = {
        title: string
        background: 'gray' | 'black'
        }

        const ProductList = ({ title, background }: Props) => (
            <S.Container background={background}>     <<<< INCLUINDO A TIPAGEM DE BACKGROUND PARA VARIAÇÃO
                <div className="container">
                <h2>{title}</h2>
                <S.List>
                    <Product                          <<<< INCLUINDO TIPAGEM SOLICITADA POR PRODUCT
                    category="Ação"
                    description="Teste"
                    image={imageDir}
                    infos={['-10%', 'R$150,00']}
                    system="Windows"
                    title="Nome do Jogo"
                    />
                    <Product
                    category="Ação"
                    description="Teste"
                    image={imageDir}
                    infos={['-10%', 'R$150,00']}
                    system="Windows"
                    title="Nome do Jogo"
                    />
                    <Product
                    category="Ação"
                    description="Teste"
                    image={imageDir}
                    infos={['-10%', 'R$150,00']}
                    system="Windows"
                    title="Nome do Jogo"
                    />
                    <Product
                    category="Ação"
                    description="Teste"
                    image={imageDir}
                    infos={['-10%', 'R$150,00']}
                    system="Windows"
                    title="Nome do Jogo"
                    />
                </S.List>
                </div>
            </S.Container>
        )

        export default ProductList

        Agora em styles onde fazemos a verifiação e troca conforme o valor retornado

        ProductList/style.ts

        import styled from 'styled-components'
        import { Props } from '.'
        import { colors } from '../../styles'
        import { Card } from '../Product/styles'

        export const Container = styled.section<Omit<Props, 'title'>>`
            padding: 32px 0;
            background-color: ${(props) =>
                props.background === 'black' ? colors.black : colors.gray};

            ${Card} {
                background-color: ${(props) =>
                props.background === 'black' ? colors.gray : colors.black};
            }
        `

        Aqui importamos os tipos na Props mas omitimos titulo pois so queremos verificar background
        criamos função if se receber black o fundo vai ser preto se nao cinza.
        ativamos estilização do card por css no productlist para variar conforme o fundo do container.
        criamos função if para o card tambem se receber black o fundo vai ser cinza se nao preto.
    
        ////////////////////////////////////////////////////////////////////////////////////////////////////////

        Por final para teste, adicionamos em App.tsx mais um Productlist mas alterando os valores enviados:

        const rotas = createBrowserRouter([
        {
            path: '/',
            element: (
            <>
                <Banner />
                <ProductList title="Promoções" background="gray" />
                <ProductList title="Em Breve" background="black" />    
            </>
            )
        }
        ])
    
        Assim conseguimo enxergar as variações da componentização funcionando

    1.7 - Construindo a Página
        1.7.1 - Organizando a página e tirando um pouco do hard coded
            Aqui iremos organizar as paginas
            tirar as maiorias das informações em hard coded e passar por informações recebidas atraves de arrays

            Primeiro vamos criar uma pasta /pages para configurar mais paginas, isso é uma forma de organiação da construção do site.
            Apos isso criamos uma pasta dentro de /pages Home/index.tsx 
            aqui vamos configurar a pagina Home criando uma constante Home e exportando ela, igual está la no App.tsx, so iremos migrar para ca

            /pages/Home/index.tsx
            const Home = () => (
                <>
                    <Banner />
                    <ProductList title="Promoções" background="gray" />
                    <ProductList title="Em Breve" background="black" />
                </>
            )

            export default Home

            e alterar tambem no App.tsx

            App.tsx
            import Home from './pages/Home'

            const rotas = createBrowserRouter([
                {
                    path: '/',
                    element: <Home />  <<<<< AQUI IMPORTAMOS O HOME LÁ DA NOVA PASTA PAGES
                }                            
            ])

            /////////////////////////////////////////////////////////////////////////////////////

            Após organização feita vamos tirar o hard coded do Product list e cirar uma Classe e modelo com a tipagem de cada produto que iremos receber as informações
            Essas informações podem ser receidas de api ou banco de dados, por isso construimos um modelo para auto inclusao nos componentes solicitados.
            Aqui vamos fazer os dos produtos, para isso criamos uma pasta nova em src chamada models
            Nessa pasta criamos um arquivo Game.ts onde vamos criar a classe de tipagem que iremos receber do produto

            Em: src/models/Game.ts
            class Game {
                title: string
                category: string
                system: string
                description: string
                infos: string[]
                image: string
                id: number // incluimos esse dado aqui já pensando que ele vem la do backend

                constructor(
                    id: number,
                    title: string,
                    category: string,
                    system: string,
                    description: string,
                    infos: string[],
                    image: string
                ) {
                    this.title = title
                    this.category = category
                    this.system = system
                    this.description = description
                    this.infos = infos
                    this.image = image
                    this.id = id
                }
            }

            export default Game

            // aqui estamos criando um tipo que represente um produto entao com tudo que um produto tem. Para isso usamos models

            Após a criação do models do produto game, precisamo incluir ele no nosso codigo.
            Em components/ProductList/index.tsx precisamos incluir a array de Game[] na tipagem

            export type Props = {
                title: string
                background: 'gray' | 'black'
                games: Game[]
            }

            Depois incluir na desestrutiração e mapear a array com os tipo do que foi recebido

            const ProductList = ({ title, background, games }: Props) => (  <<<INCLUIDO NA DESESTRUTURAÇÃO
                <S.Container background={background}>
                    <div className="container">
                    <h2>{title}</h2>
                    <S.List>
                        {games.map((game) => (                              <<< MAPEAMENTO DA ARRAY MODELS
                        <Product
                            key={game.id}
                            category={game.category}
                            description={game.description}
                            image={game.image}
                            infos={game.infos}
                            system={game.system}
                            title={game.title}
                        />
                        ))}
                    </S.List>
                    </div>
                </S.Container>
            )

            ////////////////////////////////////////////////////////////////////////////////

            Agora para o código funcionar precisamos enviar a informação da array de games também.
            Então voltamos para /pages/Home/index.tsx e vamos criar duas const em array com as informações em cada tipo de cada produto para validação
            criamos a const promocoes e emBreve

            import resident from '../../assets/images/resident.png'
            import diablo from '../../assets/images/diablo.png'
            import zelda from '../../assets/images/zelda.png'
            import star_wars from '../../assets/images/star_wars.png'

            const promocoes: Game[] = [
            // o :Game[] foi incluido apenas para ajudar no autocomplete das arrays
                {
                    id: 1,
                    category: 'Ação',
                    description:
                    'Lorem ipsum, dolor sit amet consectetur adipisicing elit. Maxime accusantium neque quo officiis qui magnam velit similique dolorem, quaerat iure, reprehenderit rerum rem? Quam libero dignissimos, accusantium nesciunt aliquam repellat!',
                    system: 'Windows',
                    title: 'Resident Evil 4',
                    infos: ['10%', 'R$ 250,00'],
                    image: resident
                },
                {
                    id: 2,
                    category: 'Ação',
                    description:
                    'Lorem ipsum, dolor sit amet consectetur adipisicing elit. Maxime accusantium neque quo officiis qui magnam velit similique dolorem, quaerat iure, reprehenderit rerum rem? Quam libero dignissimos, accusantium nesciunt aliquam repellat!',
                    system: 'Windows',
                    title: 'Diablo',
                    infos: ['5%', 'R$ 290,00'],
                    image: diablo
                },
                {
                    id: 3,
                    category: 'Ação',
                    description:
                    'Lorem ipsum, dolor sit amet consectetur adipisicing elit. Maxime accusantium neque quo officiis qui magnam velit similique dolorem, quaerat iure, reprehenderit rerum rem? Quam libero dignissimos, accusantium nesciunt aliquam repellat!',
                    system: 'Windows',
                    title: 'Zelda',
                    infos: ['10%', 'R$ 250,00'],
                    image: zelda
                },
                {
                    id: 4,
                    category: 'Ação',
                    description:
                    'Lorem ipsum, dolor sit amet consectetur adipisicing elit. Maxime accusantium neque quo officiis qui magnam velit similique dolorem, quaerat iure, reprehenderit rerum rem? Quam libero dignissimos, accusantium nesciunt aliquam repellat!',
                    system: 'Windows',
                    title: 'Star Wars',
                    infos: ['10%', 'R$ 250,00'],
                    image: star_wars
                }
            ]

            const emBreve: Game[] = [
            // o :Game[] foi incluido apenas para ajudar no autocomplete das arrays
                {
                    id: 5,
                    category: 'Ação',
                    description:
                    'Lorem ipsum, dolor sit amet consectetur adipisicing elit. Maxime accusantium neque quo officiis qui magnam velit similique dolorem, quaerat iure, reprehenderit rerum rem? Quam libero dignissimos, accusantium nesciunt aliquam repellat!',
                    system: 'Windows',
                    title: 'Resident Evil 4',
                    infos: ['17/05'],
                    image: resident
                },
                {
                    id: 6,
                    category: 'RPG',
                    description:
                    'Lorem ipsum, dolor sit amet consectetur adipisicing elit. Maxime accusantium neque quo officiis qui magnam velit similique dolorem, quaerat iure, reprehenderit rerum rem? Quam libero dignissimos, accusantium nesciunt aliquam repellat!',
                    system: 'Windows',
                    title: 'Diablo',
                    infos: ['17/05'],
                    image: diablo
                },
                {
                    id: 7,
                    category: 'Ação',
                    description:
                    'Lorem ipsum, dolor sit amet consectetur adipisicing elit. Maxime accusantium neque quo officiis qui magnam velit similique dolorem, quaerat iure, reprehenderit rerum rem? Quam libero dignissimos, accusantium nesciunt aliquam repellat!',
                    system: 'Windows',
                    title: 'Zelda',
                    infos: ['18/05'],
                    image: zelda
                },
                {
                    id: 8,
                    category: 'Ação',
                    description:
                    'Lorem ipsum, dolor sit amet consectetur adipisicing elit. Maxime accusantium neque quo officiis qui magnam velit similique dolorem, quaerat iure, reprehenderit rerum rem? Quam libero dignissimos, accusantium nesciunt aliquam repellat!',
                    system: 'Windows',
                    title: 'Star Wars',
                    infos: ['18/05'],
                    image: star_wars
                }
            ]

            const Home = () => (
                <>
                    <Banner />
                    <ProductList games={promocoes} title="Promoções" background="gray" />
                    <ProductList games={emBreve} title="Em Breve" background="black" />
                </>
            )

            Além disso, enviamos as informações das arrays das const criadas atraves do atributo games= referente a cada seção variavel

            ///////////////////////////////////////////////////////////////////////////////////////////////

        1.7.2 - Criando a pagina de categorias 
            Primeiramente vamos fazer uma copia da pages/Home pois a pagina de categoria é muito parecida, mas vamos mudar as informações
            Alterar o nome para Categories e atualizar o codigo e incluir as 4 categorias que tem na página 

            Agora vamos mudar a forma de quando clica em Categorias no Cabeçalho:
            Em Header/index.tsx no primeiro <a> alterar para <Link to="/categories">Categorias</Link>
            para isso deve importar Link do react-router-dom 
            Com isso criamos um caminho até a página de categorias ao clicar no cabeçãlho
            
            import { Link } from 'react-router-dom'

            const Header = () => (
            <S.HeaderBar>
                <div>
                <img src={logo} alt="EPLAY" />
                <nav>
                    <S.Links>
                    <S.LinkItem>
                        <Link to="/categories">Categorias</Link> <<<< SO MODIFICAMOS AQUI FAZENDO O CAMINHO COM REACT-ROUTER-DOM 
                    </S.LinkItem>
                    <S.LinkItem>
                        <a href="#">Novidades</a>
                    </S.LinkItem>
                    <S.LinkItem>
                        <a href="#">Promoções</a>
                    </S.LinkItem>
                    </S.Links>
                </nav>
                </div>
            )

            ////////////////////////////////////////////////////////////////

            Como estamos usando um o Link que é da biblioteca react-router-dom no Header e ele não está dentro do RouteProvider da um erro.
            Para funcinar precisamos mudar um pouco a rota.
            Importamos do react-router-dom o BrowserRouter para colocar em toda a aplicação 
            tambem precisamos criar uma nova constante de rotas
            para isso apagamos a forma de rota anteriro e criamos um novo arquivo em src
            
            criar src/routes.tsx e exportar a nova constante de rotas:
            Em: src/routes.tsx 

            import { Routes, Route } from 'react-router-dom'
            import Home from './pages/Home'
            import Categories from './pages/Categories'

            const Rotas = () => (
                <Routes>
                    <Route path="/" element={<Home />} />
                    <Route path="/categories" element={<Categories />} />
                </Routes>
            )

            export default Rotas

            ///////////////////////////

            Após criar um arquivo de rotas e criar a constante, importar isso no App.tsx
            App.tsx completo ficando dessa forma com a nova rota:

            import { BrowserRouter } from 'react-router-dom'
            import Header from './components/Header'
            import GlobalCss from './styles'
            import Rotas from './routes'

            function App() {
            return (
                <BrowserRouter>
                <GlobalCss />
                <div className="container">
                    <Header />
                </div>
                <Rotas />
                </BrowserRouter>
            )
            }

            //BrowserRouter faz funcionar o react-router-dom em todo a aplicação
            export default App

            Objetivo disso foi deixar nosso App.tsx mais limpo e organizado, e tambem fazer com que toda a aplicação consiga utilizar coisas do react-router-dom

            ////////////////////////////////////////////////////////////////////////////////////////////////
    
    1.8 - Construindo o Rodapé
        Aqui não tem segredo, criar em componente uma pasta Footer para configuração e estilização 
        dentro um arquivo index.tsx e style.ts

        foi criado a const Footer com toda a seção e o css aplicado em styles.ts
        a const currentYear ela é uma função para ver que ano estamos e alterar na copywritght de forma automatica

        Em Footer/index.tsx

        import * as S from './styles'

        const currentYear = new Date().getFullYear()

        const Footer = () => (
            <S.Container>
                <div className="container">
                <S.FooterSection>
                    <S.SectionTitle>Categorias</S.SectionTitle>
                    <S.Links>
                    <li>
                        <S.Link>RPG</S.Link>
                    </li>
                    <li>
                        <S.Link>Ação</S.Link>
                    </li>
                    <li>
                        <S.Link>Aventuras</S.Link>
                    </li>
                    <li>
                        <S.Link>Esportes</S.Link>
                    </li>
                    <li>
                        <S.Link>Simulação</S.Link>
                    </li>
                    <li>
                        <S.Link>Estratégia</S.Link>
                    </li>
                    <li>
                        <S.Link>FPS</S.Link>
                    </li>
                    </S.Links>
                </S.FooterSection>
                <S.FooterSection>
                    <S.SectionTitle>Acesso Rápido</S.SectionTitle>
                    <S.Links>
                    <li>
                        <S.Link>Novidades</S.Link>
                    </li>
                    <li>
                        <S.Link>Promoções</S.Link>
                    </li>
                    <li>
                        <S.Link>Em Breve</S.Link>
                    </li>
                    </S.Links>
                </S.FooterSection>
                <p>{currentYear} - &copy; E-PLAY todos os direitos reservado</p>
                </div>
            </S.Container>
        )

        export default Footer

        Em Footer/style.ts

        import styled from 'styled-components'
        import { colors } from '../../styles'

        export const Container = styled.footer`
            background-color: ${colors.gray};
            padding: 32px 0;
            font-size: 14px;
        `

        export const SectionTitle = styled.h4`
            color: ${colors.white};
            font-size: 16px;
            font-weight: bold;
        `

        export const Links = styled.ul`
            display: flex;
            margin-top: 16px;
        `

        export const Link = styled.a`
            color: ${colors.lightGray};
            text-decoration: none;
            margin-right: 8px;
        `

        export const FooterSection = styled.div`
            margin-bottom: 64px;
        `

        /////////////////////////////////////////////////////////

        Após isso o footer já esta feito e so necessario incluir no App.tsx
        Abaixo de <Rotas /> incluir o <Footer />

        function App() {
            return (
                <BrowserRouter>
                <GlobalCss />
                <div className="container">
                    <Header />
                </div>
                <Rotas />
                <Footer />   <<<<< INCLUIDO O FOOTER
                </BrowserRouter>
            )
        }
        
        //////////////////////////////////////////////////////////////////

        Assim finzalimos a Primeira Parte do projeto da E-Play M35 - Projeto 6 - Parte 1

2 - Projeto 6 - Criando Página de Detalhes e Rota por Produto   

    2.1 - Criando e entendendo as Rotas para a página de detalhe de produto interativa
        criar em /pages uma pasta chamada Product
        incluir uma rota em routes.tsx levando para Product 
        aqui vamos ter uma diferença na rota, pois alem do primeiro slug ainda vamos puxar pelo id do produto cirando mais uma

        const Rotas = () => (
            <Routes>
                <Route path="/" element={<Home />} />
                <Route path="/categories" element={<Categories />} />
                <Route path="/product/:id" element={<Product />} />     <<<<<<< NOVA ROTA
            </Routes>
        )

        path="/product/:id" está assim para alem da referencia de produtos o path buscar tambem o parameto solicitado depois da /: 
        nesse caso vamos buscar pelo id recebido do produto 

        pages/Product/index.tsx
        import { useParams } from 'react-router-dom'

        const Product = () => {
            const { id } = useParams()
            return <div>Produto {id}</div>
        }

        export default Product

        no arquivo do Produto utilizamos mais uma função do react router dom useParams() para utilizar os paramentro das desestruturação da const.

    2.2 - Estilizando o Banner da seção de Detalhes do Produto Interativo

        Aqui vamos criar o Banner e estilizar junto com as informações nele.
        Criar um componente Hero e passar ele dentro e Produtc/index.tsx

        index.tsx 
        import fundo from '../../assets/images/fundo_hogwarts.png'
        import Button from '../Botao'
        import Tag from '../Tag'
        import * as S from './styles'

        const Hero = () => (
            <S.Banner style={{ backgroundImage: `url(${fundo})` }}>
                <div className="container">
                <div>
                    <Tag>RPG</Tag>
                    <Tag>PS5</Tag>
                </div>
                <S.Infos>
                    <h2>Hogwarts Legacy</h2>
                    <p>
                    <span>De R$250,00</span>
                    Por R$ 190,00
                    </p>
                    <Button
                    type="button"
                    title="Clique aqui para adcionar esse jogo ao carrinho"
                    variant="primary"
                    >
                    Adicionar ao Carrinho
                    </Button>
                </S.Infos>
                </div>
            </S.Banner>
        )

        export default Hero

        ////////////////////////////////////////////////////
        styles.ts

        import styled from 'styled-components'
        import { colors } from '../../styles'
        import { TagContainer } from '../Tag/styles'

        export const Banner = styled.div`
            position: relative;
            display: block;
            height: 480px;
            width: 100%;
            background-repeat: no-repeat;
            background-position: center;
            background-size: 100%;
            padding-top: 16px;

            &::after {                                <<<<<< CRIA A SOBREPOSIÇÃO COM OPACIDADE NO BANER
                position: absolute;
                background-color: #000;
                opacity: 0.56;
                width: 100%;
                height: 100%;
                top: 0;
                left: 0;
                content: '';
            }

            .container {                            
                z-index: 1;                           <<<<<  SOLUÇÃO PARA TEXTOS FICAREM POR CIMA DA SOBREPOSIÇÃO                          
                position: relative;                   <<<<<
                display: flex;
                flex-direction: column;
                height: 100%;
                justify-content: space-between;
            }

            ${TagContainer} {
                margin-right: 8px;
            }
        `

        export const Infos = styled.div`
            padding: 16px;
            background-color: ${colors.black};
            max-width: 290px;
            font-weight: bold;

            h2 {
                font-size: 32px;
            }

            p {
                font-size: 18px;
                margin: 16px 0;

                span {
                display: block;
                text-decoration: line-through;
                }
            }
        `
        /////////////////////////////////////////////////////////////////////

        DETALHE DA ALTERAÇÃO NO Botao

        <Button
            type="button"
            title="Clique aqui para adcionar esse jogo ao carrinho"
            variant="primary"
            >
            Adicionar ao Carrinho
        </Button>

        nessa seção do botão criamos uma nova propiredade para o botão, em vez de criar toda uma estilização nova em componente/Botao
        então em Botao/index.tsx adicionamos variant nas propriedade como opcional incluindo 'primary' e 'secundary' como retornamos

        ficou assim:

        export type Props = {
            type: 'button' | 'link' // tipo de dado
            title: string // titulo do dado
            to?: string // caminho
            onClick?: () => void // isso permite o recebeimneto de uma função que nao tem argumento e devolver nada
            children: string // texto do botao
            variant?: 'primary' | 'secondary'     <<<<< NOVA PROPIREDADE
        }

        const Button = ({
            type,
            title,
            to,
            onClick,
            children,
            variant = 'primary'
            }: Props) => {
            if (type === 'button') {
                return (
                <S.ButtonContainer
                    type="button"
                    title={title}
                    onClick={onClick}
                    variant={variant}
                >
                    {children}
                </S.ButtonContainer>
                )
        }
            }

        exportamos Props para importar em styles e fazer  verificação
        em styles.ts incluimos <Props> em ButtonContainer e verificamos no fundo e na backgroundImage

        export const ButtonContainer = styled.button<Props>`
            background-color: ${(props) =>
                props.variant === 'primary' ? colors.green : 'transparent'};
            color: ${colors.white};
            border: 2px solid
                ${(props) => (props.variant === 'primary' ? colors.green : colors.white)};
            font-size: 16px;
            font-weight: bold;
            padding: 8px 16px;
            border-radius: 8px;
        `

        Assim, quando o botao recebe 'primary' ele fica de um jeito e se recebe 'secundary' outro

    2.3 - Criando as Seções na pagina de Detalhes do Produto
        Aqui vamos criar um novo componente chamado Section.
        como as seções dessa pagina são identicas as estilização da de categorias, podemos componentizar algumas coonst de ProductList
        Então copiamos o arquivo styles de ProductList e colamos em Section/styles.ts
        Além disso, para funcionar precisamos criar algumas propriedades em Section
        Ficando assim:

        index.tsx:

        import * as S from './styles'

        export type Props = {
            title: string
            background: 'black' | 'gray'
            children: JSX.Element
        }

        const Section = ({ title, background, children }: Props) => (
            <S.Container background={background}>
                <div className="container">
                <S.Title>{title}</S.Title>
                {children}
                </div>
            </S.Container>
        )

        export default Section
        
        //////
        styles.ts

        import styled from 'styled-components'
        import { Props } from '.'
        import { colors } from '../../styles'
        import { Card } from '../Product/styles'

        export const Container = styled.section<Omit<Props, 'title' | 'games'>>`   <<<<REUTLIZAMOS DE PRODUCTLIST
            padding: 32px 0;                                                           INCLUINDO ESTILIZAÇÃO PARA ESSA PAGINA
            background-color: ${(props) =>
                props.background === 'black' ? colors.black : colors.gray};

            ${Card} {
                background-color: ${(props) =>
                props.background === 'black' ? colors.gray : colors.black};
            }

            p {
                font-size: 14px;
                line-height: 22px;
                max-width: 640px;
            }
        `

        export const Title = styled.h2`   <<<<REUTLIZAMOS DE PRODUCTLIST 
            font-size: 18px;                    INCLUINDO ESTILIZAÇÃO PARA ESSA PAGINA
            font-weight: bold;
            margin-bottom: 40px;
        `
        ///////////////////////////////////////////////////////////////////////////////

        Após finalizar a crianção da Secão, incluir ela em Product
        criamos 3 seção conforme o figma
        2 de texto e uma que preparamos que será a seção interativa com imagens.
        Ficando assim:

        import { useParams } from 'react-router-dom'
        import Hero from '../../components/Hero'
        import Section from '../../components/Section'

        const Product = () => {
            const { id } = useParams()
            return (
                <>
                <Hero />
                <Section background="black" title="Sobre o Jogo">
                    <p>
                    Hogwarts Legacy é um RPG de ação imersivo e de mundo aberto ambientado
                    no mundo introduzido pela primeira vez nos livros do Harry Potter.
                    Embarque em uma jornada por locais novos e familiares enquanto explora
                    e descubra animais fantásticos, personalize seu personagem e crie
                    poções, domine o lançamento de feitiços, aprimore talentos e torne-se
                    o bruxo que deseja ser.Experimente Hogwarts da década de 1800. Seu
                    personagem é um estudante com chave de um antigo segredo que ameaça
                    destruir o mundo bruxo. Faça aliados, lute contra os bruxos das trevas
                    e decida o destino do mundo bruxo. Seu legado é o que você faz dele.
                    Viva o Inesperado.
                    </p>
                </Section>
                <Section background="gray" title="Mais Detalhes">
                    <p>
                    <b>Plataforma:</b> PlayStation 5 <br />
                    <b>Desenvolvedor:</b> Avalanche Software <br /> <b>Editora:</b>{' '}
                    Portkey Games, subsidiária da Warner Bros. Interactive Entertainment{' '}
                    <br /> <b>Idiomas:</b>O jogo oferece suporte a diversos idiomas,
                    incluindo inglês, espanhol, francês, alemão, italiano, português,
                    entre outros. As opções de áudio e legendas podem ser ajustadas nas
                    configurações do jogo.
                    </p>
                </Section>
                <Section background="black" title="Galeria">
                    <p>fotos</p>
                </Section>
                </>
            )
        }

        export default Product

        /////////////////////////////////////////////////////////////////////////////////

    2.4 - Criando a Galeria na Seção da pagina Part 1
        Aqui criamos um componente separado para Gallery, para nao ficar muito grando o codigo em seções 
        e por utilizarmos varias coisa, então é bom separar e incluir depois abaixo da seção em Product.
        No componente de Gallery criamos uma lista com 4 imagens para iniciar   

        index.tsx:

        import Section from '../Section'
        import zelda from '../../assets/images/zelda.png'
        import * as S from './styles'

        const Gallery = () => (
            <Section background="black" title="Galeria">
                <S.Items>
                <S.Item>
                    <img src={zelda} alt="imagem do link" />
                </S.Item>
                <S.Item>
                    <img src={zelda} alt="imagem do link" />
                </S.Item>
                <S.Item>
                    <img src={zelda} alt="imagem do link" />
                </S.Item>
                <S.Item>
                    <img src={zelda} alt="imagem do link" />
                </S.Item>
                </S.Items>
            </Section>
        )

        export default Gallery


        styles.ts

        import styled from 'styled-components'
        import { colors } from '../../styles'

        export const Items = styled.ul`
            display: flex;
        `

        export const Item = styled.li`
            margin-right: 16px;
            img {
                border: 2px solid ${colors.white};
                border-radius: 8px;
                width: 150px;
                height: 150px;
                // object-fit: cover;   <<< isso funciona igual o background-size mas para img
            }
        `

        Finalizando a estilização da seção de Gallery

    2.5 - Criando a Galeria na Seção da pagina Part-2 e MODAL

        2.5.1 - Finalizando Seção
            Para dar continuidade na criação da seçãode Gallery, vamos criar um mock temporario com hard coded para estilização de icones e MODAL
            Então em idndex.tsx criamos uma tipo com propriedades de tipo e url
            e no mock vamos passar as informações. Lembrando que é temporario, depois vamos config com api

            type GalleryItem = {
                type: 'image' | 'video'
                url: string
            }

            const mock: GalleryItem[] = [
                {
                    type: 'image',
                    url: spider
                },
                {
                    type: 'image',
                    url: potter
                },
                {
                    type: 'video',
                    url: 'https://www.youtube.com/embed/vRtANJND3Xo?si=k80gbYmYnyKPwaJQ'
                }
            ]

            Somente com isso e fazendo um map do mock na ul S.Items já conseguimos puxar as informações.
            Mas temos detalhes nos icones, se for video aparecer o icone de play e se for imagem de zoom.
            Também, se caso o tipo for video, para aparecer na pagina precisa recever um valor de url de imagem para cobrir o video
            Esse valor vai receber de Gallery, então criamos mais um tipo de propiredade para const Gallery
            Apos isso criamos as 2 funções para veriricar tanto para o icone de zoom e play quando para a url de cover caso for video

            ficando assim: 
            index.tsx

            import Section from '../Section'
            import spider from '../../assets/images/banner-homem-aranha.png'
            import potter from '../../assets/images/fundo_hogwarts.png'
            import play from '../../assets/images/play.png'
            import zoom from '../../assets/images/zoom.png'
            import close from '../../assets/images/fechar.png'
            import * as S from './styles'

            type GalleryItem = {
                type: 'image' | 'video'
                url: string
            }

            const mock: GalleryItem[] = [
                {
                    type: 'image',
                    url: spider
                },
                {
                    type: 'image',
                    url: potter
                },
                {
                    type: 'video',
                    url: 'https://www.youtube.com/embed/vRtANJND3Xo?si=k80gbYmYnyKPwaJQ'
                }
            ]

            type Props = {
                defaultCover: string
                name: string
            }

            const Gallery = ({ defaultCover, name }: Props) => {
                const getMediaCover = (item: GalleryItem) => {    <<<< função que verirfica se for imagem returna a url do item se for video vai utilizar a url recebida na função
                    if (item.type === 'image') return item.url
                    return defaultCover
                }

                const getMediaIcon = (item: GalleryItem) => {      <<<< função que verifica se for imagem icone de zoom e se for video icone de play
                    if (item.type === 'image') return zoom
                    return play
                }
                return (
                    <>
                    <Section background="black" title="Galeria">
                        <S.Items>
                        {mock.map((media, index) => (
                            <S.Item key={media.url}>
                            <img
                                src={getMediaCover(media)}
                                alt={`Imagem ${index + 1} de ${name}`}
                            />
                            <S.Action>
                                <img
                                src={getMediaIcon(media)}
                                alt="Clique para maximizar a mídia"
                                />
                            </S.Action>
                            </S.Item>
                        ))}
                        </S.Items>
                    </Section>
                    </>
                )
            }

            export default Gallery

            /////////////////////

            styles.ts

            export const Items = styled.ul`
                display: flex;
            `

                export const Action = styled.div`
                position: absolute;
                top: 0;
                left; 0;
                width: 100%;
                height: 100%;
                background-color:rgba(0,0,0,0.73);
                display: flex;
                align-items: center;
                justify-content: center;
                opacity: 0;
                transition: opacity 0.5s ease;
            `

                export const Item = styled.li`
                margin-right: 16px;
                position: relative;

                > img {
                    border: 2px solid ${colors.white};
                    border-radius: 8px;
                    width: 150px;
                    height: 150px;
                    object-fit: cover;
                }

                &:hover {
                    ${Action} {
                    opacity: 1;
                    transition: opacity 0.5s ease;
                    }
                }
            `

            Na estilização foi criado o action que é a ação do icone que ira ser acionada apenas no hover

            ///////////////////////////////////////////////////////////////////////////

        2.5.2 - Criando Modal 
            Aqui vamos criar o Modal - Imagem que ira aparecer ao clicar no produto na Galeria

            abaixo de </Section> vamos criar uma nova seção ja com a estrutura do figma
            ficando assim:

            <S.Modal>
                <S.ModalContent className="container">
                <header>
                    <h4>{name}</h4>
                    <img src={close} alt="Ícone de fechar" />
                </header>
                <img src={spider} alt="" />
                </S.ModalContent>
                <div className="overlay"></div>
            </S.Modal>

            /////////

            styles.ts

            export const Modal = styled.div`
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 1;
                display: flex;
                align-items: center;
                justify-content: center;

                .overlay {
                    position: absolute;
                    top: 0;
                    left; 0;
                    width: 100%;
                    height: 100%;
                    background-color:rgba(0,0,0,0.73);
                }
            `

                export const ModalContent = styled.div`
                max-width: 960px;
                position: relative;
                z-index: 1;

                header {
                    display: flex;
                    justify-content: space-between;
                    margin-bottom: 24px;

                    h4 {
                    font-size: 18px;
                    font-weight: bold;
                    }
                }

                img {
                    display: block;
                    max-width: 100%;
                }
            `

            foram incluidos mais essas duas constantes no styles, para o Modal

    2.6 - Criando Galeria na Seção Part - 3 Dinamismo e finalização do Modal
        Aqui vamos configurar os estados dos modais e organizar o código para melhoria do projeto.
        Para isso vamos usar o useState para alterar o estado do Modal.
        Então criamos uma constante [modal, setModal] = useState<ModalState>
        É possivel notar que o use state está utilizando uma propriendade ModalState.
        Criamos essa propriedade para receber se está visivel ou nao com valor booleano.
        Essa propriedade foi criada como a herança interface para receber tambem os valore de type e url da GalleryItem e assim evitamos copiar codigo
        Apos isso, vamos setar no cliques devidos:
            clique na imagem/video da galeria abre o modal  
            clique no icone X fecha o modal
            clique no overlay fehca o modal
        
        Para nao repetir codigo, vamos criar uma função de fechar modal como const closeModal para icone e overlay, pois os dois passam os mesmos valores
        Precisamos de uma verificação de url para se for imagem abrir a imagem e se for video a url do video
        Para isso, fizemos uma função if com ?: dentro da estrutura com <img> : <iframe>

        Ficando assim:

        import Section from '../Section'
        import spider from '../../assets/images/banner-homem-aranha.png'
        import potter from '../../assets/images/fundo_hogwarts.png'
        import play from '../../assets/images/play.png'
        import zoom from '../../assets/images/zoom.png'
        import close from '../../assets/images/fechar.png'
        import * as S from './styles'
        import { useState } from 'react'

        interface GalleryItem {                    <<<<< ALTERADO PARA INTERFACE - HERANÇA
            type: 'image' | 'video'
            url: string
        }

        const mock: GalleryItem[] = [
        {
            type: 'image',
            url: spider
        },
        {
            type: 'image',
            url: potter
        },
        {
            type: 'video',
            url: 'https://www.youtube.com/embed/vRtANJND3Xo?si=k80gbYmYnyKPwaJQ'
        }
        ]

        type Props = {
        defaultCover: string
        name: string
        }

        interface ModalState extends GalleryItem {       <<<< CRIADO PARA USESTATE UTILIZANDO HERANÇA DE OS TIPOS DE GALLERYITEMS
        isVisible: boolean
        }

        const Gallery = ({ defaultCover, name }: Props) => {
        const [modal, setModal] = useState<ModalState>({  <<<< ALTERAÇÃO DE ESTADO COM USESTATE
            isVisible: false,
            type: 'image',
            url: ''
        })
        const getMediaCover = (item: GalleryItem) => {
            if (item.type === 'image') return item.url
            return defaultCover
        }

        const getMediaIcon = (item: GalleryItem) => {
            if (item.type === 'image') return zoom
            return play
        }

        const closeModal = () => {                     <<<< FUNÇÃO PARA FECHAR MODAL
            setModal({
            isVisible: false,
            type: 'image',
            url: ''
            })
        }

        return (
            <>
            <Section background="black" title="Galeria">
                <S.Items>
                {mock.map((media, index) => (
                    <S.Item
                    key={media.url}
                    onClick={() => {
                        setModal({
                        isVisible: true,
                        type: media.type,
                        url: media.url
                        })
                    }}
                    >
                    <img
                        src={getMediaCover(media)}
                        alt={`Imagem ${index + 1} de ${name}`}
                    />
                    <S.Action>
                        <img
                        src={getMediaIcon(media)}
                        alt="Clique para maximizar a mídia"
                        />
                    </S.Action>
                    </S.Item>
                ))}
                </S.Items>
            </Section>
            <S.Modal className={modal.isVisible ? 'visivel' : ''}>   <<< VERIFICAÇÃO DE SE ESTIVER VISIVEL ATIVAR A ESTRUTURA SE NAO DISPLAY NONE
                <S.ModalContent className="container">
                <header>
                    <h4>{name}</h4>
                    <img
                    src={close}
                    alt="Ícone de fechar"
                    onClick={() => {
                        closeModal()
                    }}
                    />
                </header>
                {modal.type === 'image' ? (                 <<<< VERIFICAÇÃO SE IMAGEM URL DO ITEM COMO IMG SE FOR VIDEO COMO IFRAME
                    <img src={modal.url} alt="" />
                ) : (
                    <iframe frameBorder={0} src={modal.url} />
                )}
                </S.ModalContent>
                <div
                className="overlay"                      
                onClick={() => {                       <<<< FECHAR MODAL AO CLICAR NO OVERLAY
                    closeModal()
                }}
                ></div>
            </S.Modal>
            </>
        )
        }

        export default Gallery

    2.7 - Integrando Api - Parte 1
        2.7.1 - HOME
            Aqui vamos fazer a integração das api e configurações necessarias conforme os dados recebidos da Api
            Começamos pela página home, onde temos duas seções de ProductList promocoes e emBreve
            Precisamos substituir as constantes sa seções que estão em hardcoded para reconhecer as informações da api, alem de 
            fazer o useEffect junto com a Api
            Abrindo o link da api conseguimos ver como a array de dados que retorna para criar um propriedade de Game
            Vamos apagar as constantes e o arquivo models que estavamos utilizando ( u arquivo model é interessante quando vamos receber dados de inclução, como aqui recebemos tudo ja de uma api nãpo precisamos utilizar uma classe para isso)
            Criar duas contantes de estado do react com useState 
            Tambem iremos pegar a interface criada anteriormente em galeria: interface GalleryItem
            e colar em Home pois vamos precisar usar os tipos desa pripriedade a partir daqui 

            Ficando assim: 
            index.tsx

            import { useEffect, useState } from 'react'
            import Banner from '../../components/Banner'
            import ProductList from '../../components/ProductList'

            export interface GalleryItem {    <<<<<INTERFACE COPIADA DE GALLERY, USANDO EXPORT PARA IMPORTAR EM GALLERY TAMBEM
                type: 'image' | 'video'
                url: string
            }
 
            export type Game = {             <<<< OS DADOS QUE RETRNAM DA API, SUBTITUINDO O MODELS QUE TINHAMOS CRIANDO ANTERIORMENTE EM HARDCODED
                id: number                   <<<< ESSE DADOS CONSEGUIMOS VERIFICAR AO ABRIR O LINK DA API E ENTAO CRIAMOS A ARRAY
                name: string
                description: string
                release_date?: string
                prices: {
                    discount?: number
                    old?: number
                    current?: number
                }
                details: {
                    category: string
                    system: string
                    developer: string
                    publisher: string
                    languages: string[]
                }
                media: {
                    thumbnail: string
                    cover: string
                    gallery: GalleryItem[]
                }
            }

            const Home = () => {
                const [promocoes, setPromocoes] = useState<Game[]>([])   <<<< ALTERAÇÃO DE ESTADOS COM REACT TANtO PARA A ARRAY PROMOCOES QUANTO PARA EMBREVE
                const [emBreve, setEmBreve] = useState<Game[]>([])       <<<< EM USESTATE QUEREMOS QUE SEJA REFERENTE A ARRAY DA PROPRIEDADE GAME POR ISSO useState<Game[]>([])

                useEffect(() => {                                        <<<< CHAMADA DE DADOS DA API POR USEEFFECT E LINK DA API 
                    fetch('https://fake-api-tau.vercel.app/api/eplay/promocoes')
                    .then((res) => res.json())
                    .then((res) => setPromocoes(res))

                    fetch('https://fake-api-tau.vercel.app/api/eplay/em-breve')
                    .then((res) => res.json())
                    .then((res) => setEmBreve(res))
                }, [])
                return (
                    <>
                    <Banner />
                    <ProductList games={promocoes} title="Promoções" background="gray" />
                    <ProductList games={emBreve} title="Em Breve" background="black" />
                    </>
                )
            }

            export default Home
            ////
            Assim finalizamos o a configuração por api na pagina de Home nas seções de ProductList,
            porem o banner não altera, e temos api para cada banner individualmente, para isso, vamos tratar com ele em seu Proprio componente
        
        2.7.2 - BANNER

            Aqui vamos criar a alteração dos banner, com as informações deles conforme recebe de suas api
            Então como ja temos nossa propriedade de Game criada em Home vamos importar ela para Banner/index.tsx
            A partir disso vamos criar a constante de alteração de estado e a ligação com a api
            Vamos atualizar a estrutura do banner com os recebimentos de estado da array de Game
            Por utlimo vamos fazer uma verificação em game pois ele pode vir undefined
            Essa verificação fará com que se chegar um valor undefined vai renderizar 'Carregando...' até chegar o valor para renderizar o game recebido

            Ficando assim:
            Banner/index.tsx
            import { useEffect, useState } from 'react'
            import * as S from './styles'
            import Tag from '../Tag'
            import Button from '../Botao'
            import { Game } from '../../pages/Home'
            import { parseToBrl } from '../ProductList'

            const Banner = () => {
            const [game, setGame] = useState<Game>()     <<< constante de alteração de estado de game buscando array de Game importade de pages/Home 

                useEffect(() => {                        <<<LIGAÇÃO DA API 
                    fetch('https://fake-api-tau.vercel.app/api/eplay/destaque')
                    .then((res) => res.json())
                    .then((res) => setGame(res))
                }, [])

                if (!game) {                             <<< VERIFICAÇÃO SE RECEBER UM VALOR 'undefined'
                    return <h3>Carregando...</h3>
                }
                return (
                    <S.Imagem style={{ backgroundImage: `url(${game.media.cover})` }}>   <<< INCLUIDO INFORMAÇÕES RECEBIDAS DA API DE DESTEQUE CONFORME A TIPAGEM DA ARRAY DA PROPRIEDADE GAME
                    <div className="container">
                        <Tag size="big">Destaque do Dia</Tag>
                        <div>
                        <S.Titulo>{game.name}</S.Titulo>
                        <S.Precos>
                            De <span>{game.prices.old}</span>
                            <br />
                            por apenas {game.prices.current}
                        </S.Precos>
                        </div>
                        <Button
                        type="link"
                        to="/produto"
                        title="Clique aqui para aproveitar essa oferta"
                        >
                        Aproveitar
                        </Button>
                    </div>
                    </S.Imagem>
                )
            }

            export default Banner

            //////
            Tambem criamos um &::after dentro da tag Imagem para escurecer os banner em styles.ts
            Em Banner/styles foi incluido:

            export const Imagem = styled.div`
                width: 100%;
                height: 560px;
                display: block;
                background-repeat: no-repeat;
                background-size: cover;
                font-weight: bold;
                position: relative;

                .container {
                    position: relative;
                    padding-top: 340px;
                    display: flex;
                    justify-content: space-between;
                    align-items: flex-end;
                    z-index: 1;
                }

                ${TagContainer} {
                    position: absolute;
                    top: 32px;
                }

                    &::after {
                    position: absolute;
                    top: 0;
                    left; 0;
                    width: 100%;
                    height: 100%;
                    background-color:rgba(0,0,0,0.7);
                    content: '';
                }
            `
            Assim finalizamos a configuração com api dos banners, agora vamos para a pagina de categorias
       
        2.7.3 - PRODUTOS    
            Agora vamos ajustar a parde de Products e ProductsList
            Em ProductsList 
                Alterar a importação de Game para a que foi criada em pages/Home pois models foi excluida
                Alterar na estrutura as propriedades conforme como recebe da api da nova array de Game[]
                Para puxar a infos de forma correta precisamos criar um constante para puxar Tags e desestruturar
                Então criamos uma arrow function com algumas verificação em if e que da um push para uma array vazia para retornar os valores caso tenha.
                Além disso, para finalizar esteticamente criamos uma função basica para formatar o preço em reais, que vamos usar nesse arquivo e em Banner tambem 

                Ficando assim: 
                ProductList/index.tsx

                import { Game } from '../../pages/Home'    <<<<NOVA IMPORTAÇÃO DA PROPRIEDADE GAME
                import Product from '../Product'
                import * as S from './styles'

                export type Props = {
                    title: string
                    background: 'gray' | 'black'
                    games: Game[]
                }
                export const parseToBrl = (preco = 0) => {        <<<< FUNÇÃO PARA FORMATAR PREÇO
                    return new Intl.NumberFormat('pt-BR', {
                        style: 'currency',
                        currency: 'BRL'
                    }).format(preco)
                }

                const ProductList = ({ title, background, games }: Props) => {
                    const getGameTags = (game: Game) => {           <<<< CONST PARA VERIFICAR TAGS E RETORNAR PARA INFOS
                        const tags = []                             <<<< ARRAY VAZIA PARA SER INCLUIDA INFORMAÇÕES DOS PUSH ABAIXO

                        if (game.release_date) {                    <<< VERIFICAÇÃO DE RELEASE-DATE, SE TIVER COLOCA NA ARRAY DA TAG
                        tags.push(game.release_date)
                        }

                        if (game.prices.discount) {                 <<< VERIFICAÇÃO DE DISCONTO, SE TIVER COLOCA NA ARRAY DA TAG
                        tags.push(`${game.prices.discount}%`)
                        }

                        if (game.prices.current) {                  <<< VERIFICAÇÃO DE CURRENT, SE TIVER COLOCA NA ARRAY DA TAG
                        tags.push(parseToBrl(game.prices.current))
                        }

                        return tags                                 <<< RETORNA TAG COM AS INFORMAÇÃOES PREEENCHIDAS NA ARRAY
                    }
                    return (
                        <S.Container background={background}>
                        <div className="container">
                            <h2>{title}</h2>
                            <S.List>
                            {games.map((game) => (
                                <Product                           <<<< TODA ESSA ESTRUTURA FOI ATUALIZADA CONFORME TIPOS DA ARRAY DA NOVA PROPRIEDADE
                                key={game.id}
                                category={game.details.category}
                                description={game.description}     
                                image={game.media.thumbnail}
                                infos={getGameTags(game)}          <<<<< FUNÇÃO PARA VERIFICAR AS TAGS
                                system={game.details.system}
                                title={game.name}
                                />
                            ))}
                            </S.List>
                        </div>
                        </S.Container>
                    )
                }

                export default ProductList

                Em styles alteramos apenas o columns-gap: 24px; para gap:24px para dar espaçamento na coluna e row.

            Em Products
                Aqui vamos apenas fazer um slice para estetica dos cards dos produtos
                Com isso colocamos um tanto de caracteres que vai aceitar e depois colocar '...'
                Isso serve para deixar todos os card alinhados.
                Então vamos cirar um constante para receber a descrição do produto e ao passar pela função
                a descrição vai somente retornar 92 caracteres mais '...'
                Então vamos fazer uma verificação if se a descrição for > 95 ai corta a descrição se for menor apenas retorna ela mesmo
                Apos função criada, receber na estrutura em S.Descricao enviando description

                Ficando assim:
                Products/index.tsx

                import * as S from './styles'
                import Tag from '../Tag'

                type Props = {
                    title: string
                    category: string
                    system: string
                    description: string
                    infos: string[]
                    image: string
                }

                const Product = ({
                    title,
                    category,
                    system,
                    description,
                    infos,
                    image
                    }: Props) => {
                    const getDrescricao = (descricao: string) => { <<<< FUNÇAO CRIADA PARA REDUZIR DESCRIÇÃO E ALINHAR CARDS
                        if (descricao.length > 95) {
                        return descricao.slice(0, 92) + '...'
                        }
                        return descricao
                    }
                    return (
                        <S.Card>
                        <img src={image} alt={title} />
                        <S.Infos>
                            {infos.map((info) => (
                            <Tag key={info}>{info}</Tag>
                            ))}
                        </S.Infos>
                        <S.Titulo>{title}</S.Titulo>
                        <Tag>{category}</Tag>
                        <Tag>{system}</Tag>
                        <S.Descricao>{getDrescricao(description)}</S.Descricao>  <<< RECEBIMENTO DA FUNÇÃO CRIADA ACIMA
                        </S.Card>
                    )
                }

                export default Product

                Em styles alteramos apenas incluimos o object-fit: cover em img dentro de Cards

        2.7.4 - CATEGORIAS
            Para finalizar a primeira parte das configurações de api vamos fazer a pagina de categorias.
            Aqui temos 5 categorias diferentes que recebem informações de suas respectivas adipisicing
            Então vamos criar os estados para cada categoria e a ligação com api
            Precisamos alterar a importação de Game para pages/Home
            Apos a configração de estados prontas e a api, atualizar a estrurura com os dados corretos

            Ficando assim:
            pages/Categories/index.tsx

            import { useEffect, useState } from 'react'
            import ProductList from '../../components/ProductList'
            import { Game } from '../Home'                                <<<<< ALTERAÇÃO NA IMPORTAÇÃO 

            const Categories = () => {
                const [gamesAcao, setGameAcao] = useState<Game[]>([])               <<<< CRIAÇÃO DE ESTADOS PARA CADA CATEGORIA USANDO A ARRAY DE GAME
                const [gameEsportes, setGameEsportes] = useState<Game[]>([])
                const [gamesSimulacao, setGameSimulacao] = useState<Game[]>([])
                const [gamesLuta, setGameLuta] = useState<Game[]>([])
                const [gamesRPG, setGameRPG] = useState<Game[]>([])

                useEffect(() => {                                                   <<<< LIGAÇÃO COM A API E RECEBIMENTO DE DADOS DE CADA CATEGORIA
                    fetch('https://fake-api-tau.vercel.app/api/eplay/acao')
                    .then((res) => res.json())
                    .then((res) => setGameAcao(res))

                    fetch('https://fake-api-tau.vercel.app/api/eplay/esportes')
                    .then((res) => res.json())
                    .then((res) => setGameEsportes(res))

                    fetch('https://fake-api-tau.vercel.app/api/eplay/simulacao')
                    .then((res) => res.json())
                    .then((res) => setGameSimulacao(res))

                    fetch('https://fake-api-tau.vercel.app/api/eplay/luta')
                    .then((res) => res.json())
                    .then((res) => setGameLuta(res))

                    fetch('https://fake-api-tau.vercel.app/api/eplay/rpg')
                    .then((res) => res.json())
                    .then((res) => setGameRPG(res))
                }, [])
                return (
                    <>
                    <ProductList games={gamesAcao} title="Ação" background="black" />           <<<< ESTRUTURA DA PAGINA JA COM OS DADOOS RECEBIDOS DA API DE CADA CATEGORIA ORGANIZADOS.
                    <ProductList games={gameEsportes} title="Esportes" background="gray" />
                    <ProductList games={gamesSimulacao} title="Simulação" background="black"/>
                    <ProductList games={gamesLuta} title="Luta" background="gray" />
                    <ProductList games={gamesRPG} title="RPG" background="black" />
                    </>
                )
            }

            export default Categories

    2.8 - Integrando Api - Parte 2
        
        2.8.1 - BANNER 
            Primeiramente em Banner vamos mudar o direcionamento do Buttom de to={'/product} para:
            to={`/product/${game.id}`}
        
        2.8.2 - PAGES/PRODUCT
            AQUI VAMOS CRIAR O ESTADO ATRAVES DA PROPRIEDADE GAME E PASSAR A UTILIZAR O useParams(), tambem vamos fazer a ligação com api
            Na conficuração com a api lembrar que nesse caso tem a dependencia do id, por isso que na array do useEffect tem id.
            depois atualizamos a estrutura com os dados recebidos do estado (game)

            ficando assim:
            import { useParams } from 'react-router-dom'
            import Hero from '../../components/Hero'
            import Section from '../../components/Section'
            import Gallery from '../../components/Gallery'
            import { useEffect, useState } from 'react'
            import { Game } from '../Home'

            const Product = () => {
                const { id } = useParams()
                const [game, setGame] = useState<Game>()      <<<< ESTADOS DE TIPOS DA PROPRIEDADE GAME

                useEffect(() => {                             <<<< LIGAÇÃO COM API
                    fetch(`https://fake-api-tau.vercel.app/api/eplay/jogos/${id}`)
                    .then((res) => res.json())
                    .then((res) => setGame(res))
                }, [id])                                        <<<< ID COMO DEPENDENCIA

                if (!game) {                                   <<<< QUANDO RECEBE 'undefined' DE GAME
                    return <h3>Esta Carregando...</h3>
                }
                return (
                    <>
                    <Hero game={game} />
                    <Section background="black" title="Sobre o Jogo">
                        <p>{game.description}</p>
                    </Section>
                    <Section background="gray" title="Mais Detalhes">
                        <p>
                        <b>Plataforma:</b> {game.details.system} <br />
                        <b>Desenvolvedor:</b> {game.details.developer} <br /> <b>Editora:</b>{' '}
                        {game.details.publisher} <br /> <b>Idiomas:</b>O jogo oferece suporte
                        a diversos idiomas, incluindo {game.details.languages.join(', ')}   <<<< .join(', ) É PARA SEPARAR O QUE TIVER NA ARRAY COM ', '
                        </p>
                    </Section>
                    <Gallery
                        defaultCover={game.media.cover}
                        name={game.name}
                        items={game.media.gallery}
                    />
                    </>
                )
            }

            export default Product

        2.8.3 - GALLERY 
            Agora vamos tirar a array mock que fizemos anteriormente em hardcoded para estilizar o site,
            Vamos receber essas informações pela api, para isso, precisamos receber dentro de Porps o items da interface GalleryItem[]    
            Apos essa alteração const Gallery passa a receber na sua função 'items' tambem e onde estava 
            mock.map mudar para items.map
            Depois apagar a const mock criada anteriormente

            ficando assim:

            import Section from '../Section'
            import play from '../../assets/images/play.png'
            import zoom from '../../assets/images/zoom.png'
            import close from '../../assets/images/fechar.png'
            import * as S from './styles'
            import { useState } from 'react'
            import { GalleryItem } from '../../pages/Home'

            type Props = {
                defaultCover: string
                name: string
                items: GalleryItem[]        <<<<< INCLUIDO PARA RECEBER DA API E NAO MAIS DE MOCK
            }

            interface ModalState extends GalleryItem {
                isVisible: boolean
            }

            const Gallery = ({ defaultCover, name, items }: Props) => {  <<<<< INCLUIDO PARA RECEBER items NA CONST GALLERY
                const [modal, setModal] = useState<ModalState>({
                    isVisible: false,
                    type: 'image',
                    url: ''
                })
                const getMediaCover = (item: GalleryItem) => {
                    if (item.type === 'image') return item.url
                    return defaultCover
                }

                const getMediaIcon = (item: GalleryItem) => {
                    if (item.type === 'image') return zoom
                    return play
                }

                const closeModal = () => {
                    setModal({
                    isVisible: false,
                    type: 'image',
                    url: ''
                    })
                }

                return (
                    <>
                    <Section background="black" title="Galeria">
                        <S.Items>
                        {items.map((media, index) => (    <<<< ALTERADO DE mock.map PARA items.map
                            <S.Item
                            key={media.url}
                            onClick={() => {
                                setModal({
                                isVisible: true,
                                type: media.type,
                                url: media.url
                                })
                            }}
                            >
                            <img
                                src={getMediaCover(media)}
                                alt={`Imagem ${index + 1} de ${name}`}
                            />
                            <S.Action>
                                <img
                                src={getMediaIcon(media)}
                                alt="Clique para maximizar a mídia"
                                />
                            </S.Action>
                            </S.Item>
                        ))}
                        </S.Items>
                    </Section>
                    <S.Modal className={modal.isVisible ? 'visivel' : ''}>
                        <S.ModalContent className="container">
                        <header>
                            <h4>{name}</h4>
                            <img
                            src={close}
                            alt="Ícone de fechar"
                            onClick={() => {
                                closeModal()
                            }}
                            />
                        </header>
                        {modal.type === 'image' ? (
                            <img src={modal.url} alt="" />
                        ) : (
                            <iframe frameBorder={0} src={modal.url} />
                        )}
                        </S.ModalContent>
                        <div
                        className="overlay"
                        onClick={() => {
                            closeModal()
                        }}
                        ></div>
                    </S.Modal>
                    </>
                )
            }

            export default Gallery

        2.8.4 - PRODUCT
            Aqui em product primeiro em styles fazer o Card nao ser mais um styled.div e sim um Link com o react-router-dom
            Apos a alteração em styles e importação do mesmo vamos alterar no index.tsx
            Para direcionar para a pagina correta precisamos receber o id, então incluimos em Props e no recebimento da constante
            apos isso conseguimos alterar em S.Card incluind o direcionamento com react-router-dom com to={`/product/${id}`}

            Ficando assim: 
            styles.ts

            export const Card = styled(Link)`   <<< ALTERANDO DE .DIV PARA (LINK)
                .....
            `

            index.tsx

            import * as S from './styles'
            import Tag from '../Tag'

            type Props = {
                title: string
                category: string
                system: string
                description: string
                infos: string[]
                image: string
                id: number                  <<<< ID INCLUIDO EM PROPS
            }

            const Product = ({
                title,
                category,
                system,
                description,
                infos,
                image,
                id                          <<<< ID INCLUIDO PARA RECEBIMENTO NA CONSTANTE
                }: Props) => {
                const getDrescricao = (descricao: string) => {
                    if (descricao.length > 95) {
                    return descricao.slice(0, 92) + '...'
                    }
                    return descricao
                }
                return (
                    <S.Card to={`/product/${id}`}>   <<<< DIRECIONAMENTO COM REACT-ROUTER-DOM COM ID
                    <img src={image} alt={title} />
                    <S.Infos>
                        {infos.map((info) => (
                        <Tag key={info}>{info}</Tag>
                        ))}
                    </S.Infos>
                    <S.Titulo>{title}</S.Titulo>
                    <Tag>{category}</Tag>
                    <Tag>{system}</Tag>
                    <S.Descricao>{getDrescricao(description)}</S.Descricao>
                    </S.Card>
                )
            }

            export default Product

        2.8.5 - PRODUCTLIST 
            Agora que os produtos tambem recebem id, precisamos alterar a forma de leitura da estrutura daqui
            no game.map primeira vai verificar o id na li, para depois jogar as informações para a estrurua do produto ja com as informações corretas da api
            então o key nao fica mais em Product e sim na li criada e em product é incluido o tipo id
            
            ficando assim:
            
            .....
            return (
                <S.Container background={background}>
                <div className="container">
                    <h2>{title}</h2>
                    <S.List>
                    {games.map((game) => (
                        <li key={game.id}>                       <<<< LI CRIADA PARA RECEBER A KEY EM ID E CONTINUAR COM AS INFORMAÇÕES NA API DO ID RECEBIDO
                        <Product
                            id={game.id}                         <<<<< ID INCLUIDO EM PRODUCT 
                            category={game.details.category}
                            description={game.description}
                            image={game.media.thumbnail}
                            infos={getGameTags(game)}
                            system={game.details.system}
                            title={game.name}
                        />
                        </li>
                    ))}
                    </S.List>
                </div>
                </S.Container>
            )

        2.8.6 - HERO
            Aqui vamos ajustar com verificações quando tiver disconte ou nao, se ja tiver lançado o jogo e assim por diante
            Para começar criamos um tipo de Propriedade para receber Game
            importamos Game de pages/Home
            Passamos na const, desestruturando game
            Incluimos agora os valores recebidos de games conforme a estrutura
            e fazemos as verificações conforme mostrado abaixo.

            ficando assim:
         
            import { Game } from '../../pages/Home'                                 <<<<< IMPORTAÇÃO DE GAME 
            import Button from '../Botao'
            import { parseToBrl } from '../ProductList'
            import Tag from '../Tag'
            import * as S from './styles'

            type Props = {                                                         <<<<<< CRIAÇÃO DO TIPO DE PROPS PARA RECEBER GAME
                game: Game
            }

            const Hero = ({ game }: Props) => (                                   <<<<<< INCLUIDO NA CONST PARA RECEBER INFOS
                <S.Banner style={{ backgroundImage: `url(${game.media.cover})` }}>      <<<<< TUDO QUE COMECA COM game. É INFORMAÇÃO QUE VAI RECEBER DA API 
                    <div className="container">
                    <div>
                        <Tag>{game.details.category}</Tag>
                        <Tag>{game.details.system}</Tag>
                    </div>
                    <S.Infos>
                        <h2>{game.name}</h2>
                        <p>
                        {game.prices.discount && (                               <<<< VERIFICAÇÃO SE RECEBER ALGUM VALOR EM DISCOUNT VAI APARECER O SPAN, CASO NAO , NAO APARECE
                            <span>De {parseToBrl(game.prices.old)}</span>
                        )}
                        {game.prices.current && <>Por {parseToBrl(game.prices.current)}</>} <<<<< VERIFICAÇÃO SE RECEBER VALOR EM CURRENT O TEXTO, SE RECEBER APARECE, SE NAO, NÃO APARECE
                        </p>
                        {game.prices.current && (                                <<<<< VERIFICAÇÃO SE RECEBER VALOR EM CURRENT, SE RECEBER APARECE O BOTAO, SE NAO, NÃO APARECE
                        <Button
                            type="button"
                            title="Clique aqui para adcionar esse jogo ao carrinho"
                            variant="primary"
                        >
                            Adicionar ao Carrinho
                        </Button>
                        )}
                    </S.Infos>
                    </div>
                </S.Banner>
            )

            export default Hero

3 - Projeto 6 - Criando Página de carrinho de compra, adicionar ao carrinho e soma do valor a ser pago
    
    3.1 - Configurando o Redux e Redux Toolkit
        Primeiramente vamos instalar as dependencias com:
        npm i --save @reduxjs/toolkit react-redux

        3.1.1 - REACT

            Após a instalação vamos começar a configurar o react
            Em componentes criar a pasta store onde sera o mecanismos dos produtos no carrinho
            No arquivo index.ts vamos fazer a configuração da store
            Com:

            import { configureStore } from '@reduxjs/toolkit'

            export const store = configureStore({
            reducer: {}
            })

            export type RootReducer = ReturnType<typeof store.getState>

            /////

            Configuração da store feita, vamos cirar o primeiro reducer que vao ser das ações do carrinho
            Mas inicialmente so vamos criar uma ação de add para testar
            Então criamos uma pasta dentro de store chamda /reducers e um arquivo carrinho.ts
            Em cart.ts vamos criar o Slice do carrinho da seguinte forma:

            import { createSlice, PayloadAction } from '@reduxjs/toolkit'
            import { Game } from '../../../pages/Home'

            type CartState = {        <<<<IMPORTAÇÃO DA ARRAY DE GAME
            items: Game[]         
            }

            const initialState: CartState = {
            items: []               <<<< ESTADO INICIAL DO CARRINHO
            }

            const cartSlice = createSlice({   <<<< CRIAÇÃO DA FUNÇÃO SLICE
            name: 'cart',
            initialState,
            reducers: {
                add: (state, action: PayloadAction<Game>) => {  <<<< REDUCER COM A APLICAÇÃO DE ADICIONAR NO CARRINHO
                state.items.push(action.payload)
                }
            }
            })

            export const { add } = cartSlice.actions
            export default cartSlice.reducer

            Assim finalizamos a configuração do react com store e o reducer da acao do carrinho

        3.1.2 - REDUX 
            Para configurar o redux precisamos apenas em App.tsx e incluir a rota Provider do react-redux
            O Provider sera a tag pai de todo o App.tsx para funcionar.
            Entaõ importamos do 'react-redux' o provider e incluimos como pai na estrutura
            Tambem importamos a store para passar pelo provider

            import { Provider } from 'react-redux'  <<<<<IMPORTAÇÃO DO PRIVIDER
            import { BrowserRouter } from 'react-router-dom'

            import Header from './components/Header'
            import GlobalCss from './styles'
            import Rotas from './routes'
            import Footer from './components/Footer'
            import { store } from './components/store' <<<< IMPORTAR STORE

            function App() {
                return (
                    <Provider store={store}>  <<<< INCLUIDO COMO PAI PASSANDO A STORE 
                    <BrowserRouter>
                        <GlobalCss />
                        <div className="container">
                        <Header />
                        </div>
                        <Rotas />
                        <Footer />
                    </BrowserRouter>
                    </Provider>
                )
            }

            //BrowserRouter faz funcionar o react-router-dom em todo a aplicação
            export default App

    3.2 - Configurando Requisições dos Api para o React Toolkit Query

        3.2.1 - CONFIG SERVICES/API.TS
            Agora vamos alterar todas as formas que chamamos as apis anteriromente com o react toolkit Query
            Eu achei dessa forma mais simples
            Primeiro criamos uma pasta services em src com um api.ts
            Em api.ts vamso importar os { createApi, fetchBaseQuery } de '@reduxjs/toolkit/query/react'
            Com isso conseguios fazer a const api ficando dessa forma:

            import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'
            import { Game } from '../pages/Home'

            const api = createApi({
                baseQuery: fetchBaseQuery({                                               <<<<< A BASE DAS APIS
                    baseUrl: 'https://fake-api-tau.vercel.app/api/eplay'
                }),
                endpoints: (builder) => ({                                               <<<<< OS ENDPOINTS DE CADA API PARA CHAMAR COM FUNCOES ESPECIFICAS                                   
                    getFeaturedGame: builder.query<Game, void>({
                    query: () => 'destaque'
                    }),
                    getOnSale: builder.query<Game[], void>({
                    query: () => 'promocoes'
                    }),
                    getOnSoon: builder.query<Game[], void>({
                    query: () => 'em-breve'
                    }),
                    getActionGames: builder.query<Game[], void>({
                    query: () => 'acao'
                    }),
                    getSportsGames: builder.query<Game[], void>({
                    query: () => 'esportes'
                    }),
                    getSimulationGames: builder.query<Game[], void>({
                    query: () => 'simulacao'
                    }),
                    getRPGGames: builder.query<Game[], void>({
                    query: () => 'rpg'
                    }),
                    getFightGames: builder.query<Game[], void>({
                    query: () => 'luta'
                    }),
                    getGame: builder.query<Game, string>({                             <<<< NESSA FUNÇÃO PRECISAMOS DO ARGUMENT ID, USADO PARA DIRECIONAR PARA UM PRODUTO ESPECIFICO
                    query: (id) => `jogos/${id}`
                    })
                })
            })

            export const {                                                             <<<< EXPORTANDO FUNCÕES QUE VAO SER UTILIZADAS AO SOLICITAR AS APIS AQUI
                useGetFeaturedGameQuery,
                useGetOnSaleQuery,
                useGetOnSoonQuery,
                useGetActionGamesQuery,
                useGetFightGamesQuery,
                useGetRPGGamesQuery,
                useGetSimulationGamesQuery,
                useGetSportsGamesQuery,
                useGetGameQuery
            } = api

            export default api

            Aqui já é o arquivo completo com todas as api que usamos no projeto

            ////////////
            Tambem tivemso que importar a api em store/index.ts er config o middleware dessa forma:
            import { configureStore } from '@reduxjs/toolkit'

            import api from '../services/api'
            import cartReducer from './reducers/cart'

            export const store = configureStore({
                reducer: {
                    cart: cartReducer,
                    [api.reducerPath]: api.reducer
                },
                middleware: (getDefaultMiddleware) =>
                    getDefaultMiddleware().concat(api.middleware)
            })

            export type RootReducer = ReturnType<typeof store.getState>

        3.2.2 - CONIF DAS APIS DO PROJETO TODO COM RTK Query    
            Aqui vamos configurar todo o projeto com o RTK Query
            Então todos os arquivos que utilizavam de useState e useEffect vao ser alterados para a forma do RTK Query
            Foram alterados os arquivos pages/Home, pages/Categories e Banner inicialmente
            
            SEM ARGUMENTO ID
                Vamos usar Home como exemplo pois depois foi usado a mesma logica em todas as outras paginas:
                Apagamos os useState e useEffect pq nao vao ser mais uteis para chamar os estados das apis
                Agora criamos duas constantes de cada solicitação de api ( nesse caso era promocoes e embrave)
                Renomeamos o nome data para mais especifico
                Fizemos uma Verificação para ter receber sempre as duas constantes e seguir o codigo
                Ficando assim:

                const Home = () => {
                    const { data: onSaleGames } = useGetOnSaleQuery()     <<<<<CONST QUE BUSCA API PELA FUNÇÃO CRIADA EM API COM O DIRETORIO CORRETO PARA PROMOÇOES
                    const { data: soonGames } = useGetOnSoonQuery()       <<<<<CONST QUE BUSCA API PELA FUNÇÃO CRIADA EM API COM O DIRETORIO CORRETO PARA EM BREVE

                    if (onSaleGames && soonGames) {                       <<<< VERIFICAÇÃO PARA TER AS 2 CONSTANTE SE NAO TIVER RENDERIZAR O RETURN ABAIXO COM H4
                        return (
                        <>
                            <Banner />
                            <ProductList games={onSaleGames} title="Promoções" background="gray" />   <<<< EM GAMES= FI COLOCADO A CONSTANTE DA SUA RESPECTIVA SOLICITAÇÃO DE API E ENVIADO PARA A PAGINA
                            <ProductList games={soonGames} title="Em Breve" background="black" />
                        </>
                        )
                    }

                    return <h4>Carregando...</h4>                       <<<< SEMPRE DEVE RETORNAR ALGO, POR ISSO QUE QUANDO FIZEMOS O IF, ESSE RETURN DEVE FUNCIONAR COMO UM ELSE E NAO TRAVAR O CODIGO.
                }

                export default Home
            
            COM ARGUMENTO ID
                Aqui vamos fazer a solicitação de api passando o argumento id, usado quando clicamos em um produto especifico e buscamos as informações apenas dele

                A diferenca que na api.ts precisamos buscar uma api quando criada a query e quando utilizada é obrigatorio que passem o id para essa api, assim:

                    getGame: builder.query<Game, string>({
                        query: (id) => `jogos/${id}`   <<<<<< forma da query com o id
                    })

                Vamops usar Product como exemplo
                Seguindo a mesma linha anterios de configuração, apenas ira mudar que na função chama de api passa o paramento id
                Então apagamos tod que é useState e useEffect e criamos uma const chamando a função de api com Id
                Ficando assim:

                const { data: game } = useGetGameQuery(id!)

                So incluindo isso na função Porduct já funciona o codgio todo.

    3.3 - CRIANDO O CARRINHO
        Aqui vamos criar a estilização do carrinho conforme o figma e incluir ele para renderizar em App.tsx
        Então vamos criar uma pasta em components para o carrinho chamada Cart.
        Vamos criar a estrutura do carrinho em index.tsx e a estilização do mesmo em styles.ts
        Primeiro criamos uma estrutura basica somente para visualizar e importamos Cart em App.tsx
        Vamos importar em App.tsx porque em todas as paginas do projeto podemos abrir o carrinho.
        Entaõ em App.tsx fica assim:

        function App() {
        return (
            <Provider store={store}>
            <BrowserRouter>
                <GlobalCss />
                <div className="container">
                <Header />
                </div>
                <Rotas />
                <Footer />
                <Cart />                     <<<<< IMPORTAMOS CART AQUI PARA TER ACESSO EM QUALQUER LOCAL DO PROJETO.
            </BrowserRouter>
            </Provider>
        )
        }

        Após isso vamos estilizar completamento o carrinho
        Aqui ainda vamos utilizar as informações hardcoded, é apenas para criar o estilo e no proximo vamos configurar tudo 

        index.tsx 
        import Button from '../Botao'
        import * as S from './styles'
        import starwars from '../../assets/images/star_wars.png'
        import Tag from '../Tag'

        const Cart = () => (
            <S.CartContainer>
                <S.Overlay />    <<<<< ESSE OVERLAY É PARA QUE FIQUE O RESTO DA TELA COM OPACIDADE POR ISSO COLOCADO ANTES DO ASIDE COM FECHAMENTO JÁ
                <S.SideBar>
                <ul>
                    <S.CartItem>
                    <img src={starwars} alt="" />
                    <div>
                        <h3>Nome do Jogo</h3>
                        <Tag>RPG</Tag>
                        <Tag>PS5</Tag>
                        <span>R$150,0</span>
                    </div>
                    <button type="button" />
                    </S.CartItem>
                    <S.CartItem>
                    <img src={starwars} alt="" />
                    <div>
                        <h3>Nome do Jogo</h3>
                        <Tag>RPG</Tag>
                        <Tag>PS5</Tag>
                        <span>R$150,0</span>
                    </div>
                    <button type="button" />
                    </S.CartItem>
                </ul>
                <S.Quantity>2 jogo(s) no carrinho</S.Quantity>
                <S.Prices>
                    Total de R$ 250,00 <span>Em até 6x sem juros</span>
                </S.Prices>
                <Button type="button" title="Clique aqui para continuar com a compra">
                    Continuar com a Compra
                </Button>
                </S.SideBar>
            </S.CartContainer>
        )

        export default Cart

        ///////////////////

        styles.ts

        import styled from 'styled-components'
        import { colors } from '../../styles'
        import { TagContainer } from '../Tag/styles'
        import { ButtonContainer } from '../Botao/styles'
        import fechar from '../../assets/images/fechar.png'

        export const Overlay = styled.div`
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
        `
        export const CartContainer = styled.div`
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: flex-end;
            z-index: 1;
        `

        export const SideBar = styled.aside`
            background-color: ${colors.gray};
            z-index: 1;
            padding: 40px 16px 0 16px;
            max-width: 360px;
            width: 100%;

            ${ButtonContainer} {
                max-width: 100%;
                width: 100%;
            }
        `

        export const Prices = styled.p`
            font-size: 14px;
            font-weight: bold;
            color: ${colors.white};
            margin-bottom: 24px;

            span {
                display: block;
                font-size: 12px;
                color: ${colors.lightGray};
            }
        `

        export const Quantity = styled.p`
            font-size: 16px;
            font-weight: bold;
            color: ${colors.white};
            padding: 32px 0 16px 0;
            `
            export const CartItem = styled.li`
            display: flex;
            border-bottom: 1px solid ${colors.lightGray};
            padding: 8px 0;
            position: relative;

            img {
                height: 80px;
                width: 80px;
                object-fit: cover;
                margin-right: 24px;
            }

            h3 {
                font-size: 16px;
                font-weight: bold;
                color: ${colors.white};
            }

            span {
                display: block;
                font-size: 14px;
                font-weight: bold;
                color: ${colors.white};
            }

            ${TagContainer} {
                margin: 8px 8px 16px 0;
            }

            button {
                background-image: url(${fechar});
                width: 16px;
                height: 16px;
                border: none;
                background-color: transparent;
                position: absolute;
                top: 8;
                right: 0;
            }
        `

        ///////////////////////////

    3.4 - FUNCIONALIDADE DO CARRINHO
        3.4.1 AÇÃO DO CARRINHO VISIVEL OU NÃO
            Primeiro vamos alterar o display do CartContainer para none e criar uma classe do is-opne com display-flex
            Com isso, o carrinho vai parar de aparecer, então vamos configurar a ação nos reducers e no Cart
            Em store/reducers/cart vamos criar as duas ações, a de abrir e a de fechar carrinho e exportar 
            Tambem precisamos criar o seletor de se estiver aber com o isOpen, incluindo ele no CartState como boolean e no initialStatel como false para começar sempre fechado
            Depois dos reducers criados, vamos configurar para essa ação funcionar com seletor no Cart/index.tsx
            Então desestruturamos o isOpens com o useSelector do react-redux
            Depis incluimos uma função dentro da classe do inicio da estrutura para verificar se estiver aberta, acionar a clase is-open, se nao retornar uima string vazia.
            Ficando assim:

            styles.ts

            export const CartContainer = styled.div`  <<<< CRIAMOS A CLASSE PARA SE ESTIVER ABERTEA E ESCODEMOS O CARRINHO COM DISPLAY NONE
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                display: none;
                justify-content: flex-end;
                z-index: 1;

                &.is-open {
                    display: flex;
                }
            `

            /////////////////////////

            store/reducers/cart.ts

            type CartState = {
                items: Game[]
                isOpen: boolean                        <<<< INCLUINDO SELETOR BOOLEAN
            }

            const initialState: CartState = {
                items: [],
                isOpen: false                           <<<< INCLUINDO ESTADO INICIAL FALSE
            }

            const cartSlice = createSlice({
                name: 'cart',
                initialState,
                reducers: {
                    add: (state, action: PayloadAction<Game>) => {
                    state.items.push(action.payload)
                    },
                    open: (state) => {                  <<<< CRIANDO AÇÃO DE ABRIR
                    state.isOpen = true
                    },
                    close: (state) => {                 <<<< CRIANDO AÇÃO DE FECHAR
                    state.isOpen = false
                    }
                }
            })

                export const { add, open, close } = cartSlice.actions    <<<<<< EXPORTANDO TODOS OS REDUCERS
  
        3.4.2 - PROGRAMAR A AÇÃO DO HEADER AO CLICAR NO CARRINHO

                No Header vamos utilizar so react-redux o dispatch para acessar o reducer
                depois criamos a const para abrir carrinho.
                Em Header/index.tsx ficou assim:

                const Header = () => {
                const dispatch = useDispatch()     <<<< DISPATCH PARA LEITURA DO REDUCERS 

                const openCart = () => {            <<<< CONST PARA ABRIR O CARRINHO
                    dispatch(open())
                }
                    return (
                        <S.HeaderBar>
                        <div>
                            <Link to={'/'}>
                            <img src={logo} alt="EPLAY" />
                            </Link>
                            <nav>
                            <S.Links>
                                <S.LinkItem>
                                <Link to="/categories">Categorias</Link>
                                </S.LinkItem>
                                <S.LinkItem>
                                <a href="#">Novidades</a>
                                </S.LinkItem>
                                <S.LinkItem>
                                <a href="#">Promoções</a>
                                </S.LinkItem>
                            </S.Links>
                            </nav>
                        </div>
                        <S.CartButton onClick={openCart}>               <<<< ADICIONADO AO CLICAR AQUI ABRIR CARRINHO
                            0 - Produtos
                            <img src={carrinho} alt="Carrinho" />
                        </S.CartButton>
                        </S.HeaderBar>
                    )
                }


                ///////////////

                PARA FEHCAR O CARRINHO 
                    Fazemos algo parecido porem em Cart
                    Adicionamos o dispatch e fizemos a função de close puxando a acçao close do reducer
                    E depois incluimos no Overlay para ao clicar fechar o carrinho
                    Em Cart/index.tsx ficou assim

                    const Cart = () => {
                    const { isOpen } = useSelector((state: RootReducer) => state.cart)

                    const dispatch = useDispatch()           <<<< DISPATCH PARA LEITURA DO REDUCERS

                    const closeCart = () => {                <<<< CONST PARA ABRIR O CARRINHO
                        dispatch(close())
                    }
                    return (
                        <S.CartContainer className={isOpen ? 'is-open' : ''}>
                        <S.Overlay onClick={closeCart} />           <<<< ADICIONADO AO CLICAR AQUI FECHAR CARRINHO
                        ......
                    )}

        3.4.3 - AÇÃO PARA ADICIONAR PRODUTO AO CARRINHO
            HERO    
                No Hero vamos adicionar a acao de adic no carrinho passando a propriedade de game 
                Essa ação puxamos do reducer fazer uma função
                Vamos incluir tambem a ação de abrir o carrinho ao adicionar
                Ficando assim:
                Hero/index.tsx 

                const Hero = ({ game }: Props) => {
                    const dispatch = useDispatch()     <<<< IMPORTAMOS O DISPATCH

                    const addToCart = () => {          <<<< FUNÇÃO PARA ADD E ABRIR CARRINHO
                        dispatch(add(game))             <<< AQUI PASSAMOS A PROPS DE GAME PARA ADCIONAR COM AS IFOS DO PRODUTO RECEBIDA
                        dispatch(open())
                    }
                    return (
                        <S.Banner style={{ backgroundImage: `url(${game.media.cover})` }}>
                        <div className="container">
                            <div>
                            <Tag>{game.details.category}</Tag>
                            <Tag>{game.details.system}</Tag>
                            </div>
                            <S.Infos>
                            <h2>{game.name}</h2>
                            <p>
                                {game.prices.discount && (
                                <span>De {parseToBrl(game.prices.old)}</span>
                                )}
                                {game.prices.current && (
                                <>Por {parseToBrl(game.prices.current)}</>
                                )}
                            </p>
                            {game.prices.current && (
                                <Button
                                type="button"
                                title="Clique aqui para adcionar esse jogo ao carrinho"
                                variant="primary"
                                onClick={addToCart}                 <<<< CRIAMOS UM ONCLICK COM A FUNÇÃO DE ADD AO CARRINHO
                                > 
                                Adicionar ao Carrinho
                                </Button>
                            )}
                            </S.Infos>
                        </div>
                        </S.Banner>
                    )
                }

                export default Hero

            CART 
                Primeiramente vamos passar agora as informaçõs que recebemos mapenado o seletor item
                Apos configurar em cada lugar a informaçãp vamos fazer a função para somar itens no carrinho 
                Também precisamos criar uma função de remover item com o reducer que também vamos criar em store/reducers/cart
                Apoós isso, passar essas funções em seus devidos lugares
                Ficou assim:

                Cart/index.tsx
                const Cart = () => {
                    const { isOpen, items } = useSelector((state: RootReducer) => state.cart)  <<<< INCLUIMOS O PARA SELETOR DE ITEMS

                    const dispatch = useDispatch()

                    const closeCart = () => {
                        dispatch(close())
                    }

                    const getTotalPrice = () => {                                           <<<< FUNÇÃO PARA SOMAR VALOR DOS PRODUTOS NO CARRINHO
                        return items.reduce((acumulador, valorAtual) => {
                        return (acumulador += valorAtual.prices.current!)
                        }, 0)
                    }

                    const removeItem = (id: number) => {                                    <<<<< FUNÇÃO PARA REMOVER ITEM ATRAVES DO REDUCER REMOVE QUE VAMOS CRIAR ( ARQUIVO ABAIXO )
                        dispatch(remove(id))
                    }

                    return (
                        <S.CartContainer className={isOpen ? 'is-open' : ''}>            <<<< ESTRUTURA ATUALIZADA RECEBENDO OS VALORES DE ITEMS
                        <S.Overlay onClick={closeCart} />
                        <S.SideBar>
                            <ul>
                            {items.map((item) => (
                                <S.CartItem key={item.id}>
                                <img src={item.media.thumbnail} alt={item.name} />
                                <div>
                                    <h3>{item.name}</h3>
                                    <Tag>{item.details.category}</Tag>
                                    <Tag>{item.details.system}</Tag>
                                    <span>{parseToBrl(item.prices.current)}</span>
                                </div>
                                <button onClick={() => removeItem(item.id)} type="button" />   <<<<< ONCLICK PARA REMOVER ITEM AO CLICAR NO X
                                </S.CartItem>
                            ))}
                            </ul>
                            <S.Quantity>{items.length} jogo(s) no carrinho</S.Quantity>
                            <S.Prices>
                            Total de {parseToBrl(getTotalPrice())}{' '}                   <<<< FUNÇÃO JA CRIADA DE FORMATAR PREÇO CHAMANDO A FUNÇÃO QUE CRIAMOS PARA SOMAR VALORES DE PRODUTOS DO CARRINHO
                            <span>Em até 6x sem juros</span>
                            </S.Prices>
                            <Button type="button" title="Clique aqui para continuar com a compra">
                            Continuar com a Compra
                            </Button>
                        </S.SideBar>
                        </S.CartContainer>
                    )
                }
                export default Cart

            REDUCERS/CART
                Aqui fizemos duas alterações, a primeira foi verificar se ja tem o produto no carrinho
                e a segunda para remover produto

                const cartSlice = createSlice({
                    name: 'cart',
                    initialState,
                    reducers: {
                        add: (state, action: PayloadAction<Game>) => {
                        const game = state.items.find((item) => item.id === action.payload.id)  <<<< VERIFICA SE TEM O ITEM.ID AO SELECIONAR O PRODUTO

                        if (!game) {                                            <<<<< SE NÃO TIVER ELE FAZ A AÇÃO DE INCLUIR O PRODUTO ( SE RETORNAR UNDEFINED)
                            state.items.push(action.payload)
                        } else {                                                <<<< SE TIVER RETORNA O ALERTA QUE JA FOI ADC
                            alert('O jogo já está no carrinho')
                        }
                        },
                        remove: (state, action: PayloadAction<number>) => {
                        state.items = state.items.filter((item) => item.id !== action.payload)
                        },
                        open: (state) => {
                        state.isOpen = true
                        },
                        close: (state) => {
                        state.isOpen = false
                        }
                    }
                })

                export const { add, open, close, remove } = cartSlice.actions   <<<< EXPORTAÇÃO
                export default cartSlice.reducer

            HEADER 
                Vamos adicionar o valor atualizado de quantidade de items no carrinho
                Também vamos fazer a ação de abrir o carrinho ao clicar 

                Então importamos o dispact e desestruruamos o items e seletor de state.cart
                Após isso incluimos nos devidos lugares
                Ficando assim:

                const Header = () => { 
                    const dispatch = useDispatch()                                                  <<<<<   IMPORTAÇÃO DISPATCH
                    const { items } = useSelector((state: RootReducer) => state.cart)               <<<<< RECEBER INFOS DE ITEMS POR USESELECTOR

                    const openCart = () => {                                                        <<<< FUNÇÃO PARA ABRIR CARRINHO
                        dispatch(open())
                    }
                    return (
                        <S.HeaderBar>
                        <div>
                            <Link to={'/'}>
                            <img src={logo} alt="EPLAY" />
                            </Link>
                            <nav>
                            <S.Links>
                                <S.LinkItem>
                                <Link to="/categories">Categorias</Link>
                                </S.LinkItem>
                                <S.LinkItem>
                                <a href="#">Novidades</a>
                                </S.LinkItem>
                                <S.LinkItem>
                                <a href="#">Promoções</a>
                                </S.LinkItem>
                            </S.Links>
                            </nav>
                        </div>
                        <S.CartButton onClick={openCart}>                                       <<<< ADICIONADO ONCLICK AO CLICAR ATIVA A FUNÇÃO DE ABRIR CARRINHO
                            {items.length} - Produtos                                           <<<< NO LUGAR DO NUMERO ESCRIOT ADICIONAMOS O ITEM.LENGHT QUE PEGA A QUANTIDADE DE ITEMS QUE FOI ADICIONADO NO CARRINHO
                            <img src={carrinho} alt="Carrinho" />
                        </S.CartButton>
                        </S.HeaderBar>
                    )
                }

    3.5 - 
            3.5.1 - RESPONSIVIDADE  
            STYLES GLOBAL
                Primeiro vamos criar os breakpoints no arquivo style.ts global e verificar o que precisa ser alterado para cada breakpoints
                No arquivo style global vamos fazer um breakpoint com tamanho desktop para quando for tablet ou mobile o max-width do container ser d 80%   
                
                export const breakpoints = {          <<<<< CRIAMOS OS BREAKPOINTS PARA AUTOMATIZAR
                    desktop: '1024px',
                    tablet: '768px'
                }

                EM CONTAINER COLOCAMOS O @MEDIA PARA TABLET E CELULAR

                .container {
                    max-width: 1024px;
                    witdh: 100%;
                    margin: 0 auto;

                    @media (max-width: ${breakpoints.desktop}) {
                    max-width: 80%;
                    }
                }

            PRODUCTLIST     
                Aqui vamos ajustar apenas o grid para cada breakpoint
                Então se for tamanho tablet grid com 2 colunas e se for mobile apenas uma coluna
                Para isso criamos o breakpoint com desktop para o tablet e com o breakpoint tablet para celular 

                export const List = styled.ul`
                    display: grid;
                    grid-template-columns: repeat(4, 1fr);
                    gap: 24px;
                    margin-top: 40px;

                    @media (max-width: ${breakpoints.desktop}) {      <<<<< AQUI ALTERAMOS QUE SE FOR TABLET O GRID TERA 2 COLUNAS
                        grid-template-columns: repeat(2, 1fr);
                    }

                    @media (max-width: ${breakpoints.tablet}) {        <<<<< AQUI ALTERAMOS QUE SE FOR MOBILE O GRID TERA 1 COLUNA
                        grid-template-columns: 1fr;
                    }
                `

            HEADER 
                Inicialmente só colocamos um display none por completo pois vamos fazer depois um menu exclusivo  celular
                Então na const HeaderBar foi incluido uma @media com breakpoint para table, apenas celular com display none

                  @media (max-width: ${breakpoints.tablet}) {
                    display: none;
                }

            GALLERY 
                Aqui vamos adicionar apenas 2 coisas no display flex da ul para ajuast com a tela, sem precisar de @media
                Então incluimos em Items o row-gap para dar espacamento entre linhas e o flex-wrap: wrap para a coluna descer ao perceber que está no final da tela

                export const Items = styled.ul`
                    display: flex;
                    row-gap: 16px;              <<<< INCLUIDO
                    flex-wrap: wrap;            <<<< INCLUIDO
                `
            
            HERO
                Aqui apenas necessario fazer um cover no plano de fundo quando estiver no celular
                Para isso criamos um @media na const Banner do Hero/styles.ts conforme abaixo:

                @media (max-width: ${breakpoints.tablet}) {
                    background-size: cover;
                }

        3.5.2 - ANCORAS DO FOOTER
            Para ancorara os links que temos no footer precisamos criar ids de html nas seções dos produtos
            Então em ProductList vamos adcionar a solicitação de id={id} no S.Container pai de todas os grids criados, pois sao as requisições dos link
            Para funcionar passamos o id tambem na função de ProductList e na Propriedade
            Após isso precisamos atualizar todos os arquivos que usam o ProductList incluindo o id html em cada um individaulmente
            Foi adcionado em Home e Categories 
                Em home foi a seçao de promocao e emBreve
                Em Categories foi cada categoria que tem 
            Exemplo de um ProductList com id adicionado:
                <ProductList
                    games={onSaleGames}
                    title="Promoções"
                    background="gray"
                    id="on-sale"        <<< ID HTML ADICIONADO COM A TRING QUE QUISER
                />

            AGORA QUE TEMOS O ID HTML PRECISMOS ADICIONAR NO FOOTER PARA CADA ANCORAGEM
            Então em cada link foi incluido a # do id criado.
            Precisamos alterar a const Link em styles.ts que era 'a' para o Link e fazre a navegação
            Mas aqui temos uma observação, o react-router-dom não faz navegação por #
            Então precisamos instalar 2 pacotes que são:
                npm i --save react-router-hash-link
                npm i --save-dev @types/react-router-hash-link
            Agora alteramos o 'a' para HashLink e importamos isso do react-router-hash-link para funcionar
            Para finalizar, alterar os href para to e direcionar corretamanet cada link com o id hmtl

4 - Projeto 6 - Criando o Checkout - Menu Header Responsivo

    4.1 - Construindo a Página  
        Como nesse projeto o checkout tem um pagina unica para ela, vamos criar uma pagina em pages e fazer uma rota
        Então em pages criamos uma pasta Checkout com index.tsx
        Em routes.tsx incluimos a rota levando para checkout com o path '/checkout'
        Ficando assim:

            <Route path="/checkout" element={<Checkout />} />

        4.1.1 - CRIANDO COMPONENTE CARD

            Precismos de um componente card, pois é possivel observar que os blocos seguem as mesmas regras
            A função desse card é ter uma estilização padrão mas que consiga ler um JSX para incluir estilizações personalizadas.
            Então criamos em components a pasta Card com um index.tsx e styles.ts.
            No index.tsx criamos o componente Card.
            Esse componente vai recever um children que é um arquivo JSX e um titulo.
            Então no Card vai ter um container que vamos estilizar que sera o fundo, dentro o titulo e o children
            Ficando assim:

            import * as S from './styles'

            type Props = {
                children: JSX.Element               <<<<< FILHO QUE RECEBE JSX PARA PERSONALIZAR CAMPOS DENTRO DOS CARDS
                title: string
            }

            const Card = ({ children, title }: Props) => (
                <S.Container>                      <<<< ESTRUTURA DO CARD RECEBENDO O TITULO E O ARQUIVO JSX PERSONALIZAVEL DO CARD
                    <h2>{title}</h2>
                    {children}
                </S.Container>
            )

            export default Card

            ////////////////////////////////////////////////

            Em styles.ts de card ja estilizamos o fundo do container e estilizações padores de todo card quando utilizado

            export const Container = styled.div`
                border-radius: 8px;
                background-color: ${colors.gray};
                padding: 24px;
                margin-bottom: 40px;

                h2,
                h3 {
                    font-size: 18px;
                    font-weight: bold;
                    color: ${colors.white};
                    margin-bottom: 24px;
                }

                .margin-top {
                    margin-top: 24px;
                }

                p {
                    font-size: 14px;
                    line-height: 22px;
                }
            `

            /////////////////////////////////////////

        4.1.2 - ESTILIZANDO PAGINA DO Checkout  
            Agora que criamos o componente do card conseguimos criar os dois cards que temos no figma, os de 'Dados de Cobrança' e o de 'Pagamento'
            Como no card colocamos que o filho recebe um elemento JSX, conseguimos personalizar o que vem dentro do card.
            Para o card do Dadoe de Cobrança vamos utilizar labels e inputs para criar os campos de dados
            Em pagamentos iniciamente so iremos colocar o titulo e o texto que temos no figma.
            Ficando assim:

            pages/Checkout/index.tsx

            import Button from '../../components/Botao'
            import Card from '../../components/Card'
            import * as S from './styles'

            const Checkout = () => (
                <div className="container">
                    <Card title="Dados de cobrança">                           <<<<< UTILIZAMOS O COMPONENTE CARDS PASSANDO O TITULO DO CARD E O FILHO COMO ELEMENTO JSX
                    <>
                        <S.Row>
                        <S.InputGroup>
                            <label htmlFor="fullName">Nome Completo</label>
                            <input id="fullName" type="text" />
                        </S.InputGroup>
                        <S.InputGroup>
                            <label htmlFor="email">E-mail</label>
                            <input id="email" type="text" />
                        </S.InputGroup>
                        <S.InputGroup>
                            <label htmlFor="cpf">CPF</label>
                            <input id="cpf" type="text" />
                        </S.InputGroup>
                        </S.Row>
                        <h3 className="margin-top">Dados de entrega - conteúdo digital</h3>
                        <S.Row>
                        <S.InputGroup>
                            <label htmlFor="deliveryEmail">E-mail</label>
                            <input id="email" type="text" />
                        </S.InputGroup>
                        <S.InputGroup>
                            <label htmlFor="confirmDeliveryEmail">Confirme o E-mail</label>
                            <input id="confirmDeliveryEmail" type="text" />
                        </S.InputGroup>
                        </S.Row>
                    </>
                    </Card>                                                         <<<<<< AQUI CRIAMOS O SEGUNDO CARD. A AREA DE PAGAMENTO TAMBEM PASSANDO UM TITULO E UM OUTRO ELEMENTO JSX, ASSIM PERSONALIZAMOS OS CARDS.
                    <Card title="Pagamento">
                    <div>
                        <p>
                        Ao optar por essa forma de pagamento, é importante lembrar que a
                        confirmação pode levar até 3 dias úteis, devido aos prazos
                        estabelecidos pelas instituições financeiras. Portanto, a liberação do
                        código de ativação do jogo adquirido ocorrerá somente após a aprovação
                        do pagamento do boleto.
                        </p>
                    </div>
                    </Card>
                    <Button type="button" title="Clique aqui para fnalizar Compra">      <<<< JA INCLUIMOS UM BOTAO DE FINALIZAR COMPRA
                    Finalizar Compra
                    </Button>
                </div>
            )

            export default Checkout

            /////////////////////////////////

            pages/Checkout/styles.ts

            import { styled } from 'styled-components'
            import { colors } from '../../styles'

            export const Row = styled.div`
                display: flex;
                column-gap: 24px;
            `

            export const InputGroup = styled.div`
                flex: auto;                            <<<< com isso fazemos com que o que esta dentro se ajuste automaticamente dentro do elemento pai( se tiver display flex no pai)

                label {
                    font-size: 14px;
                    margin-bottom: 8px;
                    display: block;
                }

                input {
                    background-color: ${colors.white};
                    border: 1px solid ${colors.white};
                    height: 32px;
                    padding: 0 8px;
                    width: 100%;
                }
            `

    4.2 - Construindo a seção de pagamento do cartão
        Aqui vamos fazer a variação da estilização da parte do cartão e tambem o dinamismo dos botões com conteudo
        Caso clique em cartão vai ativar o Card de cartao e se ativar Boleto vai desativar esse card, alem de alterar as colors dos mesmos ao clicar
        
        VARIAÇÃO DE ESTADO NO INDEX.TSX PARA CLIQUE NO BOTÃO ALTERAR CONTEUD CARD
            Primeiramente vamos criar uma const de useState para o estado de pagamento com cartao, inciiando com false.
            Após isso vamos cria a verificação dentro do JSX {payWithCard ? (<></>) : (<></>)}
            Como ele inicia como false, o conteudo do cartão vem ocultado até receber o estado de true.
            Então vamos criar dois botões antes da div da verificação payWithCard, um para boleto e outro para cartão
            aqui vamos passar o onClick conforme o botão corretos
            No Botão de boleto ao clicar vai mudar o estado false, caso estiver no card do Cartão, oculta e fica com o conteudo do boleto.
            No Botão do cartão ao clicar vai mudar o estado para true, fazend com que apareco o Card do Cartão 
            
        ESTIIZAÇÃO COM VARIAÇÃO DE colors E UTILIZAÇÃO DE PROPS
            Agora que ja mudamos os estados dos botoes com seus conteudos corretos, vamos fazer a mudança tambem nos styles para mudar de colors e outras variações 
            Conforme o projeto no figma conseguios ver 3 variações de estilizações nesse campo, as dos inputs, linhas e colors
            Então vamos criar props para cada variação e incluir no index.tsx com o valor que styles vai receber e variaar na estilização;
            Os valores que vamos alterar são: em Inputs: largura maxima; em Linhas a margin-top; e no botão as colors
            
        Após tudo feito vamos ver como ficou o codigo:

        index.tsx 

        import { useState } from 'react'
        import Button from '../../components/Botao'
        import Card from '../../components/Card'
        import * as S from './styles'
        import boleto from '../../assets/images/boleto.png'
        import cartao from '../../assets/images/cartao.png'

        const Checkout = () => {
            const [payWithCard, setPayWithCard] = useState(false)     <<<< INCLUIDO PARA MUDANÇA DE ESTADO DO CONTEUDO AO CLICAR NO BOTÃO

            return (
                <div className="container">
                <Card title="Dados de cobrança">
                    <>
                    <S.Row>
                        <S.InputGroup>
                        <label htmlFor="fullName">Nome Completo</label>
                        <input id="fullName" type="text" />
                        </S.InputGroup>
                        <S.InputGroup>
                        <label htmlFor="email">E-mail</label>
                        <input id="email" type="text" />
                        </S.InputGroup>
                        <S.InputGroup>
                        <label htmlFor="cpf">CPF</label>
                        <input id="cpf" type="text" />
                        </S.InputGroup>
                    </S.Row>
                    <h3 className="margin-top">Dados de entrega - conteúdo digital</h3>
                    <S.Row>
                        <S.InputGroup>
                        <label htmlFor="deliveryEmail">E-mail</label>
                        <input id="email" type="text" />
                        </S.InputGroup>
                        <S.InputGroup>
                        <label htmlFor="confirmDeliveryEmail">Confirme o E-mail</label>
                        <input id="confirmDeliveryEmail" type="text" />
                        </S.InputGroup>
                    </S.Row>
                    </>
                </Card>
                <Card title="Pagamento">
                    <>
                    <>
                        <S.TabButton                                          <<<< BOTÃO DO BOLETO CRIADO QUE CASO ESTEJA ATIVADO VAI MOSTRAR O CONTEUDO DO CARD BOLETO E ATIVAR O VERDE NO BOTÃO 
                        isActive={!payWithCard}                               <<<< PASSADO PARA PROPRIEDADE EM STYLE RECEENDO O BOOLEAN DO ESTADO QUE CRIAMOS
                        onClick={() => setPayWithCard(false)}
                        >
                        <img src={boleto} alt="boleto" />
                        Boleto bancário
                        </S.TabButton>
                        <S.TabButton                                        <<<< BOTÃO DO CARTÃO CRIADO QUE CASO ESTEJA ATIVADO VAI MOSTRAR O CONTEUDO DO CARD CARTÃO E ATIVAR O VERDE NO BOTÃO 
                        isActive={payWithCard}                              <<<< PASSADO PARA PROPRIEDADE EM STYLE RECEENDO O BOOLEAN DO ESTADO QUE CRIAMOS
                        onClick={() => setPayWithCard(true)}                
                        >
                        <img src={cartao} alt="boleto" />
                        Cartão de crédito
                        </S.TabButton>
                        <div className="margin-top">
                        {payWithCard ? (                                   <<<<<< VERIFICAÇÃO COM O ESTADO QUE CRIAMOS, CASO payWithCard seja true retorna o Card com conteudo do cartão caso seja false retorna as do boleto
                            <>
                            <S.Row>
                                <S.InputGroup>
                                <label htmlFor="cardOwner">
                                    Nome do Titular do cartão
                                </label>
                                <input id="cardOwner" type="text" />
                                </S.InputGroup>
                                <S.InputGroup>
                                <label htmlFor="cpfCardOwner">
                                    CPF do Titular do cartão
                                </label>
                                <input id="cpfCardOwner" type="text" />
                                </S.InputGroup>
                            </S.Row>
                            <S.Row marginTop="24px">                    <<<<< TIPO CRIADO EM STYLES PARA VARIAÇÃO DE MARGIN TOP QUE PODEMOS UTILIZAR NAS S.ROW
                                <S.InputGroup>
                                <label htmlFor="cardDsplayName">Nome no cartão</label>
                                <input id="cardDisplayName" type="text" />
                                </S.InputGroup>
                                <S.InputGroup>
                                <label htmlFor="cardNumber">Número do cartão</label>
                                <input id="cardNumber" type="text" />
                                </S.InputGroup>
                                <S.InputGroup maxWidth="123px">
                                <label htmlFor="expiresMonth">Mês do vencimento</label>
                                <input id="expiresMonth" type="text" />
                                </S.InputGroup>
                                <S.InputGroup maxWidth="123px">
                                <label htmlFor="expiresYears">Ano de vencimento</label>
                                <input id="expiresYears" type="text" />
                                </S.InputGroup>
                                <S.InputGroup maxWidth="48px">
                                <label htmlFor="cardCode">CVV</label>
                                <input id="cardCode" type="text" />
                                </S.InputGroup>
                            </S.Row>
                            <S.Row marginTop="24px">
                                <S.InputGroup maxWidth="150px">                           <<<< TIPO CRIADO EM STYLES PARA VARIAÇÃO DE MAXWIDTH QUE PODEMOS UTILIZAR NAS S.INPUTGROUP
                                <label htmlFor="installments">Parcelamento</label>
                                <select name="" id="">
                                    <option value="">1x R$ 200,00</option>
                                    <option value="">2x R$ 100,00</option>
                                    <option value="">3x R$ 75,00</option>
                                </select>
                                </S.InputGroup>
                            </S.Row>
                            </>
                        ) : (
                            <p>
                            Ao optar por essa forma de pagamento, é importante lembrar que
                            a confirmação pode levar até 3 dias úteis, devido aos prazos
                            estabelecidos pelas instituições financeiras. Portanto, a
                            liberação do código de ativação do jogo adquirido ocorrerá
                            somente após a aprovação do pagamento do boleto.
                            </p>
                        )}
                        </div>
                    </>
                    </>
                </Card>
                <Button type="button" title="Clique aqui para fnalizar Compra">
                    Finalizar Compra
                </Button>
                </div>
            )
        }

        export default Checkout

        /////////////////

        styles.ts

        import { styled } from 'styled-components'
        import { colors } from '../../styles'

        type InputGroupProps = {                           <<<<< AS 3 PROPRIEDADES QUE CRIAMSO PARA CADA CONST ESPECICA RETORNANDO O VALOR COLOCADO NO INDEX.TSX
            maxWidth?: string
        }

        type RowProps = {
            marginTop?: string
        }

        type TabButtonProps = {
            isActive: boolean
        }

        export const Row = styled.div<RowProps>`                    
            display: flex;
            column-gap: 24px;
            margin-top: ${(props) => props.marginTop || '0'};        <<<< FUNÇÃO QUE ATUALIZA A ESTILIZAÇÃO CONFORME VALOR RECEBIDO DO INDEX.TSX
            align-items: flex-end;
            `

            export const InputGroup = styled.div<InputGroupProps>`
            flex: auto;

            max-width: ${(props) => props.maxWidth || 'auto'};       <<<< FUNÇÃO QUE ATUALIZA A ESTILIZAÇÃO CONFORME VALOR RECEBIDO DO INDEX.TSX

            label {
                font-size: 14px;
                margin-bottom: 8px;
                display: block;
            }

            input,
            select {
                background-color: ${colors.white};
                border: 1px solid ${colors.white};
                height: 32px;
                padding: 0 8px;
                width: 100%;
            }
            `
            export const TabButton = styled.button<TabButtonProps>`
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            color: ${colors.white};
            background-color: ${(props) => (props.isActive ? colors.green : colors.black)};    <<<< MUDANÇA DE COR DO BOTÃO = FUNÇÃO QUE ATUALIZA A ESTILIZAÇÃO CONFORME VALOR RECEBIDO DO INDEX.TSX
            height: 32px;
            border: none;
            margin-right: 16px;
            padding: 0 8px;
            cursor: pointer;

            img {
                margin-right: 8px;
            }
        `
        
    4.3 - Aplicando validações
        Instalações de duas bibliotecas
        npm i --save yup formik
        yup é utilizado para aplicar validações ao formulario
        formik ajuda a gerenciar valores e logica do formulario 
        Apos a instalação das bibliotecas e importação das mesmas vamso começar a configurar o formulario atraves delas.
        Vamos usar primeiramnete o Formik para criar os valores iniciais e esquemas de vlidações.
        Criando a constante e seus objetis vamos listar todos os inputs que temos nos dois formularios.
        Em initialValues, mostramos que todos são strings.
        Além de já incluir o onSubmit, por enquanto com um console.log para configuração, depois vamos olhar para ele
        Agora para funcionar precisamos colocar tudo dentro do JSX da const fomr criada, então colocamos no lugar da div pai pois vamos utilzar em todos os campos aqui
        Depois, vamos incluir em todos os inputs o onChange e OnBlur
        OnChage = verifica os valores alterados conforme o dado que tem em form atualmente
        OnBlur = verifica dados que estão sendo tocados/alterados
        Após isso, vamos criar os esquemas de validação. então para cada campo vamos utilizar uma função do Yup para colcoar informações e se o campo é obrigatorio
        Tudo esse objeto vai estar em uma funçlão yup.object
        Ainda aqui, vamos fazer uma validação para os inputs do cartão de credito so serem validados caso esteja a pagina do cartão aberta.
        Para isso usamos  uma outra função que verifica se estiver aberto fazer a validação dos campos.
        Feito isso, vamos configurar a mensagem de erro caso de erro na validação.
        Em todos os cinputs incluir um small com uma função  que vamos criar chamda getErrorMessage
        Elá faz com que isso so apareca caso der erro.

        Ficando assim:

        import { useState } from 'react'
        import Button from '../../components/Botao'
        import Card from '../../components/Card'
        import * as S from './styles'
        import boleto from '../../assets/images/boleto.png'
        import cartao from '../../assets/images/cartao.png'
        import { useFormik } from 'formik'
        import * as Yup from 'yup'

        const Checkout = () => {
            const [payWithCard, setPayWithCard] = useState(false)

            const form = useFormik({                           <<<<<< CRIANDO FORM COM FORMIK
                initialValues: {                               <<<<< VALORES DOS INPUTS CRIADOS
                fullName: '',
                email: '',
                cpf: '',
                deliveryEmail: '',
                confirmDeliveryEmail: '',
                cardOwner: '',
                cpfCardOwner: '',
                cardDsplayName: '',
                cardNumber: '',
                expiresMonth: '',
                expiresYears: '',
                cardCode: '',
                installments: 1
                },
                validationSchema: Yup.object({                  <<<<< ESQUEMA DE VALIDAÇÃO
                fullName: Yup.string()
                    .min(5, 'o Nome precisa ter pelo menos 5 caracateres')
                    .required('o campo é obrigatório'),
                email: Yup.string()
                    .email('E-mail Inválido')
                    .required('o campo é obrigatório'),
                cpf: Yup.string()
                    .min(14, 'CPF Inválido, o campo precisa ter no mínimo 14 caracteres.')
                    .max(14, 'CPF Inválido, o campo precisa ter no máximo 15 caracteres.')
                    .required('o campo é obrigatório'),
                deliveryEmail: Yup.string()
                    .email('E-mail Inválido')
                    .required('o campo é obrigatório'),
                confirmDeliveryEmail: Yup.string()
                    .oneOf([Yup.ref('deliveryEmail')], 'Os e-mails são diferentes')
                    .required('o campo é obrigatório'),

                cardOwner: Yup.string().when((values, schema) =>                     <<<< VALIDAÇÃO COM VERIFICAÇÃO DE SE FOR CARTÃO 
                    payWithCard ? schema.required('o campo é obrigatorio') : schema
                ),
                cpfCardOwner: Yup.string().when((values, schema) =>
                    payWithCard ? schema.required('o campo é obrigatorio') : schema
                ),
                cardDsplayName: Yup.string().when((values, schema) =>
                    payWithCard ? schema.required('o campo é obrigatorio') : schema
                ),
                cardNumber: Yup.string().when((values, schema) =>
                    payWithCard ? schema.required('o campo é obrigatorio') : schema
                ),
                expiresMonth: Yup.string().when((values, schema) =>
                    payWithCard ? schema.required('o campo é obrigatorio') : schema
                ),
                expiresYears: Yup.string().when((values, schema) =>
                    payWithCard ? schema.required('o campo é obrigatorio') : schema
                ),
                cardCode: Yup.string().when((values, schema) =>
                    payWithCard ? schema.required('o campo é obrigatorio') : schema
                ),
                installments: Yup.string().when((values, schema) =>
                    payWithCard ? schema.required('o campo é obrigatorio') : schema
                )
                }),
                onSubmit: (values) => {
                console.log(values)
                }
            })

            const getErrorMessage = (fieldName: string, message?: string) => {       <<<<<< FUNÇÃO QUE VERIFICA SE DEVE APARECER A EMNSAGEM DE ERRO
                const isTouched = fieldName in form.touched
                const isInvalid = fieldName in form.errors

                if (isTouched && isInvalid) return message
                return ''
            }

            return (  
                <form onSubmit={form.handleSubmit} className="container">           <<<<< ALTERADO A DIV POR FORM DO FORMIK COM O SUBMIT
                <Card title="Dados de cobrança">
                    <>
                    <S.Row>
                        <S.InputGroup>
                        <label htmlFor="fullName">Nome Completo</label>
                        <input
                            id="fullName"
                            type="text"
                            name="fullName"
                            value={form.values.fullName}
                            onChange={form.handleChange}                            <<<< INCLUIDO EM TODOS OS INPUTS PARA VERIFICAR ALTERAÇÃO 
                            onBlur={form.handleBlur}                                 <<<< INCLUIDO EM TODOS OS INPUTS PARA VERIFICAR SE CAMPO FOI TOCADO
                        />
                        <small>{getErrorMessage('fullName', form.errors.fullName)}</small>    <<<< CAMPO CRIADO DE MENSAGEM DE RRO QUE SO VAI APARECER DE RETORNAR DA FUNÇÃO DE VALIDAÇÃO
                        </S.InputGroup>
                        <S.InputGroup>
                        <label htmlFor="email">E-mail</label>
                        <input
                            id="email"
                            type="text"
                            name="email"
                            value={form.values.email}
                            onChange={form.handleChange}
                            onBlur={form.handleBlur}
                        />
                        <small>{getErrorMessage('email', form.errors.email)}</small>
                        </S.InputGroup>
                        <S.InputGroup>
                        <label htmlFor="cpf">CPF</label>
                        <input
                            id="cpf"
                            type="text"
                            name="cpf"
                            value={form.values.cpf}
                            onChange={form.handleChange}
                            onBlur={form.handleBlur}
                        />
                        <small>{getErrorMessage('cpf', form.errors.cpf)}</small>
                        </S.InputGroup>
                    </S.Row>
                    <h3 className="margin-top">Dados de entrega - conteúdo digital</h3>
                    <S.Row>
                        <S.InputGroup>
                        <label htmlFor="deliveryEmail">E-mail</label>
                        <input
                            id="email"
                            type="text"
                            name="deliveryEmail"
                            onChange={form.handleChange}
                            onBlur={form.handleBlur}
                            value={form.values.deliveryEmail}
                        />
                        <small>
                            {getErrorMessage('deliveryEmail', form.errors.deliveryEmail)}
                        </small>
                        </S.InputGroup>
                        <S.InputGroup>
                        <label htmlFor="confirmDeliveryEmail">Confirme o E-mail</label>
                        <input
                            id="confirmDeliveryEmail"
                            type="text"
                            name="confirmDeliveryEmail"
                            value={form.values.confirmDeliveryEmail}
                            onChange={form.handleChange}
                            onBlur={form.handleBlur}
                        />
                        <small>
                            {getErrorMessage(
                            'confirmDeliveryEmail',
                            form.errors.confirmDeliveryEmail
                            )}
                        </small>
                        </S.InputGroup>
                    </S.Row>
                    </>
                </Card>
                <Card title="Pagamento">
                    <>
                    <>
                        <S.TabButton
                        isActive={!payWithCard}
                        onClick={() => setPayWithCard(false)}
                        >
                        <img src={boleto} alt="boleto" />
                        Boleto bancário
                        </S.TabButton>
                        <S.TabButton
                        isActive={payWithCard}
                        onClick={() => setPayWithCard(true)}
                        >
                        <img src={cartao} alt="boleto" />
                        Cartão de crédito
                        </S.TabButton>
                        <div className="margin-top">
                        {payWithCard ? (
                            <>
                            <S.Row>
                                <S.InputGroup>
                                <label htmlFor="cardOwner">
                                    Nome do Titular do cartão
                                </label>
                                <input
                                    id="cardOwner"
                                    type="text"
                                    name="cardOwner"
                                    value={form.values.cardOwner}
                                    onChange={form.handleChange}
                                    onBlur={form.handleBlur}
                                />
                                <small>
                                    {getErrorMessage('cardOwner', form.errors.cardOwner)}
                                </small>
                                </S.InputGroup>
                                <S.InputGroup>
                                <label htmlFor="cpfCardOwner">
                                    CPF do Titular do cartão
                                </label>
                                <input
                                    id="cpfCardOwner"
                                    type="text"
                                    name="cpfCardOwner"
                                    value={form.values.cpfCardOwner}
                                    onChange={form.handleChange}
                                    onBlur={form.handleBlur}
                                />
                                <small>
                                    {getErrorMessage(
                                    'cpfCardOwner',
                                    form.errors.cpfCardOwner
                                    )}
                                </small>
                                </S.InputGroup>
                            </S.Row>
                            <S.Row marginTop="24px">
                                <S.InputGroup>
                                <label htmlFor="cardDsplayName">Nome no cartão</label>
                                <input
                                    id="cardDisplayName"
                                    type="text"
                                    name="cardDsplayName"
                                    value={form.values.cardDsplayName}
                                    onChange={form.handleChange}
                                    onBlur={form.handleBlur}
                                />
                                <small>
                                    {getErrorMessage(
                                    'cardDsplayName',
                                    form.errors.cardDsplayName
                                    )}
                                </small>
                                </S.InputGroup>
                                <S.InputGroup>
                                <label htmlFor="cardNumber">Número do cartão</label>
                                <input
                                    id="cardNumber"
                                    type="text"
                                    name="cardNumber"
                                    value={form.values.cardNumber}
                                    onChange={form.handleChange}
                                    onBlur={form.handleBlur}
                                />
                                <small>
                                    {getErrorMessage('cardNumber', form.errors.cardNumber)}
                                </small>
                                </S.InputGroup>
                                <S.InputGroup maxWidth="123px">
                                <label htmlFor="expiresMonth">Mês do vencimento</label>
                                <input
                                    id="expiresMonth"
                                    type="text"
                                    name="expiresMonth"
                                    value={form.values.expiresMonth}
                                    onChange={form.handleChange}
                                    onBlur={form.handleBlur}
                                />
                                <small>
                                    {getErrorMessage(
                                    'expiresMonth',
                                    form.errors.expiresMonth
                                    )}
                                </small>
                                </S.InputGroup>
                                <S.InputGroup maxWidth="123px">
                                <label htmlFor="expiresYears">Ano de vencimento</label>
                                <input
                                    id="expiresYears"
                                    type="text"
                                    name="expiresYears"
                                    value={form.values.expiresYears}
                                    onChange={form.handleChange}
                                    onBlur={form.handleBlur}
                                />
                                <small>
                                    {getErrorMessage(
                                    'expiresYears',
                                    form.errors.expiresYears
                                    )}
                                </small>
                                </S.InputGroup>
                                <S.InputGroup maxWidth="48px">
                                <label htmlFor="cardCode">CVV</label>
                                <input
                                    id="cardCode"
                                    type="text"
                                    name="cardCode"
                                    value={form.values.cardCode}
                                    onChange={form.handleChange}
                                    onBlur={form.handleBlur}
                                />
                                <small>
                                    {getErrorMessage('cardCode', form.errors.cardCode)}
                                </small>
                                </S.InputGroup>
                            </S.Row>
                            <S.Row marginTop="24px">
                                <S.InputGroup maxWidth="150px">
                                <label htmlFor="installments">Parcelamento</label>
                                <select
                                    id="installments"
                                    name="installments"
                                    value={form.values.installments}
                                    onChange={form.handleChange}
                                    onBlur={form.handleBlur}
                                >
                                    <option value="">1x R$ 200,00</option>
                                    <option value="">2x R$ 100,00</option>
                                    <option value="">3x R$ 75,00</option>
                                </select>
                                <small>
                                    {getErrorMessage(
                                    'installments',
                                    form.errors.installments
                                    )}
                                </small>
                                </S.InputGroup>
                            </S.Row>
                            </>
                        ) : (
                            <p>
                            Ao optar por essa forma de pagamento, é importante lembrar que
                            a confirmação pode levar até 3 dias úteis, devido aos prazos
                            estabelecidos pelas instituições financeiras. Portanto, a
                            liberação do código de ativação do jogo adquirido ocorrerá
                            somente após a aprovação do pagamento do boleto.
                            </p>
                        )}
                        </div>
                    </>
                    </>
                </Card>
                <Button type="button" title="Clique aqui para fnalizar Compra">
                    Finalizar Compra
                </Button>
                </form>
            )
        }

        export default Checkout

    4.4 - Menu Responsivo Header
        Aqui vamos apenas mexer no componente Header.
        no JSX vamos incluir uma div antes da logo para criar o hamburger.
        dentro dessa div terão  3 spans que vamos estilizar no styles para fcar 3 riscos apenas.
        Apos estilizada e responsiva, vamos criar o container que vai ter as opções que vao aparecer ao clicar no hambuirguer
        então colocamos tudo que esta em HeaderBar dentro de uma div e criamos uma nova const cahamda HeaderRow.
        EM HeaderRow vamos colocar toda a estilização flex dentro dela e tirar de HeaderBar
        Depois vamos copiar todo o nav e colocar abaixo de HeaderRow
        Vamos criar uma const para esse nav com display: none e estilizar a responsividade de Links e LinksItem
        Finalizamos isso, vamos criar o estado de abrir e fechar quando clicar no hamburger
        Para isso criamos os estados e incluimos que ao clicar no hamburger vem a negaçao do estado, ou seja, se tiver true troca para false e vice e verificamos
        E incluimos a verificação de classe de NavMobile se estiver aberto da display block se for false none;
        Ficando assim:

        index.tsx

        import { Link } from 'react-router-dom'
        import * as S from './styles'
        import logo from '../../assets/images/logo.svg'
        import carrinho from '../../assets/images/carrinho.svg'

        import { open } from '../../store/reducers/cart'
        import { useDispatch, useSelector } from 'react-redux'
        import { RootReducer } from '../../store'
        import { useState } from 'react'

        const Header = () => {
            const dispatch = useDispatch()
            const { items } = useSelector((state: RootReducer) => state.cart)
            const [isMenuOpen, setIsMenuOpen] = useState(false)                    <<<<< SELETOR PARA MUDANÇA DE ESTADO QUANDO CLICAR NO HAMBURGUER ABRIR O NAV

            const openCart = () => {
                dispatch(open())
            }
            return (
                <S.HeaderBar>
                <S.HeaderRow>                                                     <<<<< ROW CRIADA PARA DIVIDIR CONTEUDO QUE APARECE EM TELAS MAIORES COM O NAV QUE SO APARECE EM TABLET E QUANDO CLICA NO HAMBURGER
                    <div>
                    <S.Hamburguer onClick={() => setIsMenuOpen(!isMenuOpen)}>      <<<<< DIV CRIADA PARA FAZER O HAMBURGUER COM O ONCLICK COM A NEGAÇÃO DO ESTADO PARA ABRIR OU FECHAR AO CLICAR
                        <span />
                        <span />
                        <span />
                    </S.Hamburguer>
                    <Link to={'/'}>
                        <img src={logo} alt="EPLAY" />
                    </Link>
                    <nav>
                        <S.Links>
                        <S.LinkItem>
                            <Link to="/categories">Categorias</Link>
                        </S.LinkItem>
                        <S.LinkItem>
                            <a href="#">Novidades</a>
                        </S.LinkItem>
                        <S.LinkItem>
                            <a href="#">Promoções</a>
                        </S.LinkItem>
                        </S.Links>
                    </nav>
                    </div>
                    <S.CartButton onClick={openCart}>
                    {items.length} <span> - Produto(s)</span>
                    <img src={carrinho} alt="Carrinho" />
                    </S.CartButton>
                </S.HeaderRow>
                <S.NavMobile className={isMenuOpen ? 'is-open' : ''}>       <<<<<<< COPIA DO NAV PARA TELAS MENORES, QUE SO IRA ABRIR QUANDO RECEBER UM VALOR TRUE SE NAO FICA FECHADA, ISSO RECEBE QUANDO CLICA NO HAMBURGEUR
                    <S.Links>
                    <S.LinkItem>
                        <Link to="/categories">Categorias</Link>
                    </S.LinkItem>
                    <S.LinkItem>
                        <a href="#">Novidades</a>
                    </S.LinkItem>
                    <S.LinkItem>
                        <a href="#">Promoções</a>
                    </S.LinkItem>
                    </S.Links>
                </S.NavMobile>
                </S.HeaderBar>
            )
        }

        export default Header

        ////////////////////////////////
        
        styles.ts

        import styled from 'styled-components'
        import { breakpoints, colors } from '../../styles'

        export const Links = styled.ul`                     <<<<< TROUXEMOS LINK PARA CIMA PARA PODER ESTILZZAR ABAIXO DENTRO DO SEU PAI INDIVIDUALMENTE E RESPONSIVIDADE
            display: flex;
            margin-left: 40px;

            @media (max-width: ${breakpoints.tablet}) {    <<<<< RESPONSIVIDADE PARA NAV FICAR BLOCK EM TABLES E MOBILE
                margin-left: 0;
                display: block;
            }
            `

            export const HeaderBar = styled.header`
            background-color: ${colors.gray};
            padding: 24px;
            border-radius: 16px;
            margin-bottom: 80px;

            a {
                color: ${colors.white};
                text-decoration: none;
                font-weight: bold;
            }
        `

        export const HeaderRow = styled.div`                <<<<<< CONST CRIADA PARA SEPARAR NAV DO TABLET COM O QUE JA APARECE EM desktop
            display: flex;                                  <<<<<< ENTÃO TROUXEMOS ALGUMAS ESTILIZAÇÕES QUE ESTAVAM EM HEADBAR 
            align-items: center;
            justify-content: space-between;
            flex: flex-auto;

            > div {
                display: flex;
                align-items: center;

                @media (max-width: ${breakpoints.tablet}) {
                flex: 1;
                justify-content: space-between;
                ${Links} {
                    display: none;
                }
                }
            }
        `

        export const NavMobile = styled.div`                <<<<< CONST CRIADA PARA NAO APARECER O NAV PARA TABLET E MOBILE
            display: none;

            &.is-open {
                display: block;
            }
        `

        export const LinkItem = styled.li`
            margin-right: 16px;

            @media (max-width: ${breakpoints.tablet}) {        <<<<< RESPONSIVIDADE PARA NAV FICAR BLOCK EM TABLES E MOBILE
                margin-right: 0;
                a {
                display: block;
                padding: 16px 0;
                text-align: center;
                }
            }
        `

        export const CartButton = styled.a`
            display: flex;
            align-items: center;

            img {
                margin-left: 16px;
            }

            @media (max-width: ${breakpoints.tablet}) {             <<<<< RESPONSIVIDADE PARA NAO APARECER EM TABLES E MOBILE
                span {
                display: none;
                }
            }
        `
        export const Hamburguer = styled.div`                         <<<< CONST CRIADA COM A ESTILIZAÇÃO DO HAMBURGGUER
            width:32px;

            span {
                height: 2px;
                display: block;
                width 100%;
                background-color: ${colors.white};
                margin-bottom: 4px;
            }

            @media (min-width: ${breakpoints.tablet}) {
                display: none;
            }
        `

    4.5 - Integrando API do checkout
        Aqui vamos Integrar a api do checkout e verificar uma ação diference do servico de api
        Primeirmante vamos abri a api e ver que tipos temos que ter no nosso codigo.
        Então criamos a propriedade conforme e api e vamos chamar dentro dos endpoints.
        Criamos entao um endpoint chamado purchase mas aqui vamos fazer algo diferente.
        Quando vmaos buscar alguns dados do servido usamos o builder.query, mas para enviar dados vamos usar o builder.mutation
        Então criamos abaixo de getGames e exportamos a constante usePurchaseMutation
        Ficando assim: 
        api.ts

        type Product = {                   <<<< OS TIPOS CRIADOS RECEBIDOS DA API
            id: number
            price: number
        }

        type PurchasePayload = {            <<<< OS TIPOS CRIADOS RECEBIDOS DA API
            products: Product[]
            billing: {
                name: string
                email: string
                document: string
            }
            delivery: {
                email: string
            }
            payment: {
                card: {
                active: boolean
                owner?: {
                    name: string
                    document: string
                }
                name?: string
                number?: string
                expires?: {
                    month: number
                    year: number
                }
                code?: number
                }
                installments: number
            }
        }
            
        const api = createApi({
            baseQuery: fetchBaseQuery({
                baseUrl: 'https://fake-api-tau.vercel.app/api/eplay'
            }),
            endpoints: (builder) => ({
                .......... codigo acima
                    getGame: builder.query<Game, string>({
                    query: (id) => `jogos/${id}`
                    }),
                    purchase: builder.mutation<any, PurchasePayload>({   <<<< CRIAMOS O CAMINHO PARA API E ENVIANDO DADOS POR ISSO USAMOS O MUTATION
                    query: (body) => ({
                        url: 'checkout',
                        method: 'POST',
                        body
                    })
                })
            })
            })

            export const {
                useGetFeaturedGameQuery,
                useGetOnSaleQuery,
                useGetOnSoonQuery,
                useGetActionGamesQuery,
                useGetFightGamesQuery,
                useGetRPGGamesQuery,
                useGetSimulationGamesQuery,
                useGetSportsGamesQuery,
                useGetGameQuery,
                usePurchaseMutation            <<<<EXPORTAMOS 
            } = api
            ///////////////////////////////////////////////////////////

            Em checkout vamos fazer a funcionar a incluisao e dados nessa api quando preenchidos.
            Entao vamos em pages/Checkout e criar um const para reeber a função criada em api.ts e passar esses valor em onSubmit do Formik

            const [purchase, { isLoading, isError, data }] = usePurchaseMutation()    <<<<<< CONST PARA RECEBER/ENVIAR INFORMAÇÕES COM O ENDPOINT E PROPRIEDADE CRIADO  

               onSubmit: (values) => {                                                <<<<<< AQUI INCLUIMOS AS INFORMAÇÕES NO SUBMIT COM A FUNÇÃO DE PURCHASE COM O DADOS QUE PRECISAMOS INCLUIR DEVIDO A PROPIREDADE.
                    purchase({                                                        <<<<< A AÇÃO QUE ACONTECE AQUI É QUE RECEBE AS INFORMAÇÕES VALIDADAS E ENVIA OS DADOS PARA API COM MUTATION QUE FIZEMOS AGORA.
                        billing: {
                        document: values.cpf,
                        email: values.email,
                        name: values.fullName
                        },
                        delivery: {
                        email: values.deliveryEmail
                        },
                        payment: {
                        installments: 1,
                        card: {
                            active: payWithCard,
                            code: Number(values.cardCode),
                            name: values.cardDsplayName,
                            number: values.cardNumber,
                            owner: {
                            document: values.cpfCardOwner,
                            name: values.cardOwner
                            },
                            expires: {
                            month: 1,
                            year: 2025
                            }
                        }
                        },
                        products: [
                        {
                            id: 1,
                            price: 10
                        }
                        ]
                    })
                }

    4.6 - Criando a Página de Obrigado
        Aqui vamos cria a pagina de obrigao e fazer aparecer apos o clique de finalizar compra. então so ira passar tambem apos a validação do formulario 
        para isso vamos criar uma nova div Pai para criar o Jsx de Card para fazer a pagina de obrigado, uma vez que segue o mesmo modelo de estilização do componente Card
        Criamos os paragrafos e estilizamos o que era necessario.
        Agora para fazer a funcionalidade de quando realizado a compra com sucesso direcionar para a pagina de obrigado, vamos fazer uma condicional.
        Conseguimos puxar um dado do PurchaseMutation que é o isSuccess, que caso ele clique no botão e tudo é validado retorna um boolean true
        Então com isso criamos a condicional que se isSuccess(true) vai direcionar para o <Card> criado para a Página de Obrigado.
        Caso isSuccess for false mantem o formulario do checkout que criamos.
        Tambem depois vamos incluir os dados de numero do pedido e forma de pagamento, o id do pedido conseugimo com um dado que recebemos de data
        o data.orderId e a fotma de pagamento fazemos uma condicional que de payWithCard(ser true) retorna a string 'Cartão de credito e se form false Boleto Bancario

         const [purchase, { isLoading, isError, data, isSuccess }] =       <<<<<INCLUIMOS O ISSUCCESS PARA RECEBER INFORMAÇÃO DO MUTATION
             usePurchaseMutation()

          return (
            <div className="container">                                      <<<<< NOVA DIV PAI COM CLASS CONTAINER SEPARANDO A CONDICIONAL QUE SE FOR ISSUCCESS VAI PARA A PAGINA DE OBRIAGDO SE NAO FOR VAI PARA CHECKOUT
            {isSuccess ? (                                                  <<<<< CONDICIONAL QUE VERIFICA SE ISSUCCESS = TRUE
                <Card title="Muito Obrigado!">                               <<<< PÁGINA DE OBRIGADO JA ESTILIZADA
                <>
                    <p>
                    É com satisfação que informamos que recebemos seu pedido com
                    sucesso!
                    <br />
                    Abaixo estão os detalhes da sua compra: <br />
                    Número do pedido: {data.orderId} <br /> Forma de pagamento:{' '}
                    {payWithCard ? 'Cartão de Crédito' : 'Boleto Bancário'}
                    </p>
                    <p className="margin-top">
                    Caso tenha optado pelo pagamento via boleto bancário, lembre-se de
                    que a confirmação pode levar até 3 dias úteis. Após a aprovação do
                    pagamento, enviaremos um e-mail contendo o código de ativação do
                    jogo.
                    </p>
                    <p className="margin-top">
                    Se você optou pelo pagamento com cartão de crédito, a liberação do
                    código de ativação ocorrerá após a aprovação da transação pela
                    operadora do cartão. Você receberá o código no e-mail cadastrado
                    em nossa loja.
                    </p>
                    <p className="margin-top">
                    Pedimos que verifique sua caixa de entrada e a pasta de spam para
                    garantir que receba nossa comunicação. Caso tenha alguma dúvida ou
                    necessite de mais informações, por favor, entre em contato conosco
                    através dos nossos canais de atendimento ao cliente.
                    </p>
                    <p className="margin-top">
                    Agradecemos por escolher a EPLAY e esperamos que desfrute do seu
                    jogo!
                    </p>
                </>
                </Card>
            ) : (                                                                   <<<<<< CONDICINAL QUE SE ISSUCCESS FOR FALSE VAI PARA O FORM DE CHECKOUT QUE CRIAMOS
                <form onSubmit={form.handleSubmit}>
                    <Card title="Dados de cobrança">
                        <>
                        <S.Row>
                            <S.InputGroup>
                            <label htmlFor="fullName">Nome Completo</label>
                            <input
                                id="fullName"
                                type="text"
                                name="fullName"
                                value={form.values.fullName}
                                onChange={form.handleChange}
                                onBlur={form.handleBlur}
                            />
                            <small>
                                {getErrorMessage('fullName', form.errors.fullName)}
                            </small>
                            </S.InputGroup>
                            <S.InputGroup>
                            <label htmlFor="email">E-mail</label>
                            <input
                                id="email"
                                type="text"
                                name="email"
                                value={form.values.email}
                                onChange={form.handleChange}
                                onBlur={form.handleBlur}
                            />
                            <small>{getErrorMessage('email', form.errors.email)}</small>
                            </S.InputGroup>
                            <S.InputGroup>
                            <label htmlFor="cpf">CPF</label>
                            <input
                                id="cpf"
                                type="text"
                                name="cpf"
                                value={form.values.cpf}
                                onChange={form.handleChange}
                                onBlur={form.handleBlur}
                            />
                            <small>{getErrorMessage('cpf', form.errors.cpf)}</small>
                            </S.InputGroup>
                        </S.Row>
                        <h3 className="margin-top">
                            Dados de entrega - conteúdo digital
                        </h3>
                        <S.Row>
                            <S.InputGroup>
                            <label htmlFor="deliveryEmail">E-mail</label>
                            <input
                                id="email"
                                type="text"
                                name="deliveryEmail"
                                onChange={form.handleChange}
                                onBlur={form.handleBlur}
                                value={form.values.deliveryEmail}
                            />
                            <small>
                                {getErrorMessage(
                                'deliveryEmail',
                                form.errors.deliveryEmail
                                )}
                            </small>
                            </S.InputGroup>
                            <S.InputGroup>
                            <label htmlFor="confirmDeliveryEmail">
                                Confirme o E-mail
                            </label>
                            <input
                                id="confirmDeliveryEmail"
                                type="text"
                                name="confirmDeliveryEmail"
                                value={form.values.confirmDeliveryEmail}
                                onChange={form.handleChange}
                                onBlur={form.handleBlur}
                            />
                            <small>
                                {getErrorMessage(
                                'confirmDeliveryEmail',
                                form.errors.confirmDeliveryEmail
                                )}
                            </small>
                            </S.InputGroup>
                        </S.Row>
                        </>
                    </Card>
                    <Card title="Pagamento">
                        <>
                        <>
                            <S.TabButton
                            isActive={!payWithCard}
                            onClick={() => setPayWithCard(false)}
                            >
                            <img src={boleto} alt="boleto" />
                            Boleto bancário
                            </S.TabButton>
                            <S.TabButton
                            isActive={payWithCard}
                            onClick={() => setPayWithCard(true)}
                            >
                            <img src={cartao} alt="boleto" />
                            Cartão de crédito
                            </S.TabButton>
                            <div className="margin-top">
                            {payWithCard ? (
                                <>
                                <S.Row>
                                    <S.InputGroup>
                                    <label htmlFor="cardOwner">
                                        Nome do Titular do cartão
                                    </label>
                                    <input
                                        id="cardOwner"
                                        type="text"
                                        name="cardOwner"
                                        value={form.values.cardOwner}
                                        onChange={form.handleChange}
                                        onBlur={form.handleBlur}
                                    />
                                    <small>
                                        {getErrorMessage(
                                        'cardOwner',
                                        form.errors.cardOwner
                                        )}
                                    </small>
                                    </S.InputGroup>
                                    <S.InputGroup>
                                    <label htmlFor="cpfCardOwner">
                                        CPF do Titular do cartão
                                    </label>
                                    <input
                                        id="cpfCardOwner"
                                        type="text"
                                        name="cpfCardOwner"
                                        value={form.values.cpfCardOwner}
                                        onChange={form.handleChange}
                                        onBlur={form.handleBlur}
                                    />
                                    <small>
                                        {getErrorMessage(
                                        'cpfCardOwner',
                                        form.errors.cpfCardOwner
                                        )}
                                    </small>
                                    </S.InputGroup>
                                </S.Row>
                                <S.Row marginTop="24px">
                                    <S.InputGroup>
                                    <label htmlFor="cardDsplayName">Nome no cartão</label>
                                    <input
                                        id="cardDisplayName"
                                        type="text"
                                        name="cardDsplayName"
                                        value={form.values.cardDsplayName}
                                        onChange={form.handleChange}
                                        onBlur={form.handleBlur}
                                    />
                                    <small>
                                        {getErrorMessage(
                                        'cardDsplayName',
                                        form.errors.cardDsplayName
                                        )}
                                    </small>
                                    </S.InputGroup>
                                    <S.InputGroup>
                                    <label htmlFor="cardNumber">Número do cartão</label>
                                    <input
                                        id="cardNumber"
                                        type="text"
                                        name="cardNumber"
                                        value={form.values.cardNumber}
                                        onChange={form.handleChange}
                                        onBlur={form.handleBlur}
                                    />
                                    <small>
                                        {getErrorMessage(
                                        'cardNumber',
                                        form.errors.cardNumber
                                        )}
                                    </small>
                                    </S.InputGroup>
                                    <S.InputGroup maxWidth="123px">
                                    <label htmlFor="expiresMonth">
                                        Mês do vencimento
                                    </label>
                                    <input
                                        id="expiresMonth"
                                        type="text"
                                        name="expiresMonth"
                                        value={form.values.expiresMonth}
                                        onChange={form.handleChange}
                                        onBlur={form.handleBlur}
                                    />
                                    <small>
                                        {getErrorMessage(
                                        'expiresMonth',
                                        form.errors.expiresMonth
                                        )}
                                    </small>
                                    </S.InputGroup>
                                    <S.InputGroup maxWidth="123px">
                                    <label htmlFor="expiresYears">
                                        Ano de vencimento
                                    </label>
                                    <input
                                        id="expiresYears"
                                        type="text"
                                        name="expiresYears"
                                        value={form.values.expiresYears}
                                        onChange={form.handleChange}
                                        onBlur={form.handleBlur}
                                    />
                                    <small>
                                        {getErrorMessage(
                                        'expiresYears',
                                        form.errors.expiresYears
                                        )}
                                    </small>
                                    </S.InputGroup>
                                    <S.InputGroup maxWidth="48px">
                                    <label htmlFor="cardCode">CVV</label>
                                    <input
                                        id="cardCode"
                                        type="text"
                                        name="cardCode"
                                        value={form.values.cardCode}
                                        onChange={form.handleChange}
                                        onBlur={form.handleBlur}
                                    />
                                    <small>
                                        {getErrorMessage('cardCode', form.errors.cardCode)}
                                    </small>
                                    </S.InputGroup>
                                </S.Row>
                                <S.Row marginTop="24px">
                                    <S.InputGroup maxWidth="150px">
                                    <label htmlFor="installments">Parcelamento</label>
                                    <select
                                        id="installments"
                                        name="installments"
                                        value={form.values.installments}
                                        onChange={form.handleChange}
                                        onBlur={form.handleBlur}
                                    >
                                        <option value="">1x R$ 200,00</option>
                                        <option value="">2x R$ 100,00</option>
                                        <option value="">3x R$ 75,00</option>
                                    </select>
                                    <small>
                                        {getErrorMessage(
                                        'installments',
                                        form.errors.installments
                                        )}
                                    </small>
                                    </S.InputGroup>
                                </S.Row>
                                </>
                            ) : (
                                <p>
                                Ao optar por essa forma de pagamento, é importante lembrar
                                que a confirmação pode levar até 3 dias úteis, devido aos
                                prazos estabelecidos pelas instituições financeiras.
                                Portanto, a liberação do código de ativação do jogo
                                adquirido ocorrerá somente após a aprovação do pagamento
                                do boleto.
                                </p>
                            )}
                            </div>
                        </>
                        </>
                    </Card>
                    <Button
                        type="button"
                        onClick={form.handleSubmit}
                        title="Clique aqui para fnalizar Compra"
                    >
                        Finalizar Compra
                    </Button>
                </form>
            )}
            </div>
        )

    4.7 - Fazendo melhoria 

        - Executar o npm eslint . e verificar os warnings/ erros e ajustar para melhorar o codigo 
        Após feito isso já limpamos a maioria dos warnings organizando
        - Todo local que utliza um link colocar o title para ao passar o mouse aparecer o texto do que se trata o botão "clique aqui para...."  
        - Na responsividade ao clicar em algum item dentro do nav hamburguer a nav não fecha, então vamos criar a funcionalidade para ao clicar fehcar a nav hamburguer 
        Para isso vamos incluir onClick={() => setIsMenuOpen(false)} nos Links que queremos clicar e fechar o menu
        - Colocar titulos em card recebendo alguma propriedade, exemplo: title={`Clique aqui para ver mais detalhes do jogo ${title}`} , assim pegamos a propriedade title, que ao passar o mouse em cima do card vai alterar para o titulo do jogo 
        - Para alinhar a altura dos Card para todos ficarem iguais basta ir no styled de Cards e incluir um height:100% que todos os card ficam da mesma altura 
        - Adicionar o cursor:pointer, em links/botões que são clicaveis apra dar um retorno ao usuario 

    4.8 - Fazendo melhorias parte-2
        -  Alterar a nomenclatura dos codigos, deixando tudo em um padroa/linguagem 
        Então vamos alterar qualquer coisa que estiver em portugues para ingles ( constantes, variaveis, propriedades e etc..)
        Para isso vamos entrar em todos os arquivos e ajustar
        - Verificar funções que usamos em varios arquivos e criar uma pasta utils em src
        Nessa pasta vamos colocar todas as funções 'golbais' que usamos mais de uma vez em varios arquivos
        Por exemplo: função do parseToBrl (formataPreco)

    4.9 - Validando o checkout  
        4.9.1 - Ajustando a mensagem de erro do checkout
            Aqui vamos tirar a mensagem de erro e apenas colocar uma classe com borda em vermelho caso a validação falhe em vez do texto
            Para isso criamos ums função para chegar input, muito parecida com o getErrorMessage criada anteriormente
            Proem não vamos passar uma mensagem e na função apenas uma validação que se for tocado ou ivalido retorna, assim conseguimos fazer um ternario com validação para classe css
            Apos criar a função apagar todos os small criado com mensagem e incluir no input a classe com ternario assim:
            className={checkInputHasError('id') ? 'error' : ''}
            Assim todos os inputs quando tocado ou invalidado retorna a classe error true e vamos estilizar essa classe.
            em styles.ts dentro de inputgroup, na parte de input,select, vamos colcoar a classe &.error com a borda em vermelhor

                &.error {
                    border: 1px solid red;
                }
        
        4.9.2 - Comportamento do botão que leva até a página do carrinho/ verifica se tem 1 item pelo menos
            No botão do carrinho vamos adicionar um onClick que leva para a página do checkout
            Vamos utilizar de uma função do react-router-dom que é para navegar entre rotas
            essa função é a navigate, primeiro importamos da biblioteca e criamos uma const
            Após isso vamos criar uma const que vai servir tanto para ir para a pagina de checkout como tambem fechar o carrinho
            Criamos a função goToCheckout e fica assim:

                const navigate = useNavigate()           <<<<CONST COM IMPORTAÇÃO DO REACT-ROUTER-DOM

                const goToCheckout = () => {              <<< FUNÇÃO PARA USAR NO ONCLICK DO BOTÃO PARAR LEVAR ATER CHECKOUT E FECHAR CARRINHO
                    navigate('/checkout')
                    closeCart()
                }

            Agora precisamos fazer com que so seja direcionado par ao checkout caso tenha pelo menos um produto no carrinho
            Então no index do checkout vamos usar um seletor do carrinho para conseguir acessar as infos dos estado do carrinho
            Criamos a const com useSelector
            Então vamos fazer a verificação que de items.lenght ( dados obtidos pelo useSelector que acamos de importar) for igual a 0 ai volta para home,
            caso contrario vai seguir para o Checkout
            Algo interessante que o useNavigate da biblioteca do react-router-dom podemos usar ele como connstatne em função ou como propriedade
            Nesse caso como o if dentro do JSX deve ter um return tivemos que usar a forma de Propiredade do Navigate para passar a rota

            const { items } = useSelector((state: RootReducer) => state.cart)    <<<<< importamos useSelector e buscamos os dados em item do estado de cart

            if (items.length === 0) {                         <<<<< INCLUIDO NA CONST DO SCHECKOUT PARA VERIFDICAR SE NAO TIVER PRODUTO VOLTAR PRA HOME 
                return <Navigate to={'/'} />                  <<<<< NAVIGATE DO REACT-RPOUTER-DOM USADO COMO PROPRIEDADE POIS NÃO DARIA COMO FUNÇÃO NESSE CASO AQUI, MOSTRANDO AS POSSIBILIDADES DA BIBLIOTECA
            }

            return (
                ...............
            )                                          <<<<< CASO TENHA PRODUTO SEGUE PARA ESSE RETURN QUE É A PÁGINA DO CHECKOUT

        4.9.3 - Incluindo dados nos campos de parcelamento e funcionalidade do botão de cartão com inputs
            Primeiramente colocamos nossa função getTotalPrice dentro do nosso arquivo utils para usar em outrso lugares tambem, no caso vamos usar em checkoutr
            Criamos uma const pra o totalPrice buscando a função getTotalPrice enviando Items
            Agora vamos cria um estado para uma propridade que vamos criar tambem prar incluir dados nos parcelamentos
            Criamos o tipo Installment com tipo quantidade, preço, preço formatado
            Criamos a contante com os estados e passando useState para a propriadede Installment array 
            Antes do if para retornar as paginas, vamos fazer o useEffect para calcular os valores das parcelas, usando o totalPrice como dependencia e fazendo uma função com for para i ser no max 6
            Apos toda essa configuração, incluimos um map para installmens la na seção do parcelamente o atualizamos com os dados.

            type Installment = {      <<<<< PROPRIEDADE CRIADA PARA O PARCELAMENTO 

                quantity: number
                amount: number
                formattedAmount: string
            }

            const [intallments, setInstallments] = useState<Installment[]>([])  <<<< USO DE ESTADO CRIADO PARA O PARCELAMENT 
            const totalPrice = getTotalPrice(items)                             <<<< CONST PARA IMPORTAR A FORMATAÇÃO DO PREÇO

              useEffect(() => {                                                 <<<< USEEFFECT ANTES DO PRIMEIRO IF/RETURN, AQUI É O CALCULA DA PARCELA MAIS A QUANTIDADE, ONDE I VAI ATE 6 E PARCELADO POR O VALOR DE I 
                const calculateInstallments = () => {                           <<<< ASSIM CALCULMOS ATE O VALOR MAXIMO QUE COLOCMANOS NO FOR QUE É 6 E DIVIDIDO PELO VALOR
                const installmentsArray: Installment[] = []
                for (let i = 1; i <= 6; i++) {
                    installmentsArray.push({
                    quantity: i,
                    amount: totalPrice / i,
                    formattedAmount: parseToBrl(totalPrice / i)
                    })
                }
                return installmentsArray
                }
                if (totalPrice > 0) {
                setInstallments(calculateInstallments)
                }
            }, [totalPrice])                                                     <<<<< USANDO O TOTALPRICE COMO DEPENDENCIA DO USEEFFECT

            .....

            {intallments.map((installment) => (                                 <<<< AQUI DEPOIS DO SELECT QUE SÃO OS CAMPOS DO PARECLAMENTO CONFIGURAMOS PARA INCLUIR COM OS DADOS RECEBIDOS DE INTALLMENTS CONFORME CONFIGURMOS AGORA
                <option key={installment.quantity}>
                    {installment.quantity}x de{' '}
                    {installment.formattedAmount}
                </option>
            ))}

            ///////////////////////////////////////////////////////////////////////////////////////////////////////////

            Para ajustar o bug de quando clica em cartão de crédito todos os inputs acionam a classe de error com borda vermelhe
            Vamos em buttom e colocar mais uma opção de tipo
            Depois no if do type === 'button' vamos incluit | type === 'submit que é a nova opção de tipo e alterara na arraay type={type}
            Ai é so alterar nos botões no checkout, as obpções de TabButton (boleto e cartao) incluir o type='button e no botaõ de submit colocar type='submit'
            Assim so vai acionar a verificação para classe error se nao validar algo apos clicar no botão de finalzar compra
            Quando clicado no botão do boleto ou cartão nao faz a verificação ainda e os campos ficam normais.  

            export type Props = {
                 type: 'button' | 'link' | 'submit'   <<<< INLCUIDO NA PROPRIEDADE  
                 .....
            }

            if (type === 'button' || type === 'submit') {   <<<<< ALTERADO O IF COM A NOVA OPÇÃO DE TIPO E ALTERADO TYPE={TYPE}
                return (
                <S.ButtonContainer
                    type={type}
                    ....
            )}

        4.9.4 - Adicionando Loaders(Carregamento) 
            baixar a a biblioteca do react spinner com 
            npm i --save react-spinners
            Então vamos criar um component para o Loader e importar da biblioteca de react-spinners
            Com a pasta Loader ja com o arquivo index.tsx e styles vamos configurar
            Em index.tsx vamos criar a constante, incluir um container para importar o spinner de loader eccolhido na biblioteca

            import { PacmanLoader } from 'react-spinners'
            import { colors } from '../../styles'
            import { Container } from './styles'

            const Loader = () => (               
                <Container>
                    <PacmanLoader color={colors.white} />              <<<< IMPORTADO DA BIBLIOTECA DE SPINNERS, PRECISANDO APENAS PASSAR A COR
                </Container>
            )

            export default Loader   

            //////////////////////////////////////

            Em styels, so criamos o vampo de container

            import styled from 'styled-components'

            export const Container = styled.div`
                min-height: 360px;
                display: flex;
                align-items: center;
                justify-content: center;
            `

            /////////////////////////////////////////////

            Após a criação do componente vamos configurar no codigo.
            Em ProductList vamos incluir na propriedade um tipo para isLoading com valor booleano
            Então vamos passar ela na constante de Productlist desestruturada tambem para fazer um if antes do return, que verifica se isLoading for true reneriza o componente de isLoading
            Também temos que incluir no Omit no Container em styles.ts o 'isLoading'

            export type Props = {
                title: string
                background: 'gray' | 'black'
                games: Game[]
                id?: string
                isLoading: boolean                                                   <<<< ADICIONADO ISLOADING NA PRIPRIEDADE
            }

            const ProductList = ({ title, background, games, id, isLoading }: Props)  <<< ISLOADING INCLUIDO NA CONSTANTE 

            if (isLoading) {                                                            <<< IF PARA RENDERIXAR LOADING CASO FOR TRUE
                return <Loader />
            }

            ////////////////////////////////////////////

            Agora vamos configurar as paginas que passam pelo ProductList
            Entçao em Home, precismos incluir o tipo da propriedade em ProductList isLoading.
            Na verdae precisamos seguri essa mesma logica para todos os componentes ou paginas que usam o ProductList.
            Vou usar a Home como exemplo de alteração:

            - Primeiro vamos tirar a função if com a verificação pois vamos colocar como não obirgatorio direto na Props de ProductList
            Para evitar o erro em ProductList o games.map vai mudar para games && games.map(...)...
            - Após a configuração vamos seguir a mesma logica para todas as paginas que utilizam Productlist
            - Primeiro as const que recebe os dados da api, vamos tambem receber o isLoading alterando o nome pois nao pode repetir,
            - Após isso é so incluir o tipo isLoading da prirpiredade de ProductList, passando o valor do isLoading da query api
            Ficando assim:
            Nas Paginas Home e Categorias segue esse exemplo:

            const Home = () => {
                const { data: onSaleGames, isLoading: isLoadingSale } = useGetOnSaleQuery()
                const { data: soonGames, isLoading: isLoadingSoon } = useGetOnSoonQuery()

                return (
                    <>
                    <Banner />
                    <ProductList
                        games={onSaleGames}
                        title="Promoções"
                        background="gray"
                        id="on-sale"
                        isLoading={isLoadingSale}
                    />
                    <ProductList
                        games={soonGames}
                        title="Em Breve"
                        background="black"
                        id="comming-soon"
                        isLoading={isLoadingSoon}
                    />
                    </>
                )
            }

            export default Home

            ///////////////////////////////

            Para Banner/Product 
            -Vamos reutilizar o if (!game) criado e em vez de passar o h4 passa o Loader

            Ficando assim:

            if (!game) {
                return <Loader />
            }

        4.9.5 - Considerações finais e ajustes
            - ARQUIVO UNICO PARA PROPRIEDADES  
                aqui crimos um arquivo em src chamado 'types.d.ts' para colcoar todas sa propiredades que usamos la e não precisar importar nos arquivos.
                Criamos o arquivo e incluimos Game e GalleryItem que estavam em Home
                so mudamos o export port declare
            - AJUSTE DO DADO RECEBIDO NO MUTATION PARA TIRAR any (api)
                no endpoint purchase estavamos passando um dado any, ma apops a configuração e fazer o processo do carrinho
                descobrimos que o valor que retornava era uma orderId, então criamos uma propiredade para esse retorno e mudamos Any pela propriedade e para e alegar o warnings
                
                type PurchaseResponde = { <<<< PROPRIEDADE CRIADA
                orderId: string
                }

                purchase: builder.mutation<PurchaseResponde, PurchasePayload>({ <<<<ENDPOITN COM A PROP
            - CRIANDO TIPO DISABLE NO BOTÃO PARA VERIFICAR E ALTERAR CONFORME ESTADO O TEXTO NO BOTÃO
                Para criar um carregamento no chekout quando clicamos em finalizar compra, vamos adicionar um tipo opcional em Botão, e passar essa tipo com o isLoading que recebemos,
                Apos isso fazemos uma verificação no texto do botao que se isLoading for true renderiza 'Finalizando Compra...' e se for false ' Finalizar COmpra'

                Em componentns/Button, incluimos no Props, na const e no ButtonContainer o DISABLE
                Em Checkout, incluimos no botão o tipo e a função

                <Button
                    type="submit"
                    onClick={form.handleSubmit}
                    title="Clique aqui para finalizar Compra"
                    disabled={isLoading}
                >
                    {isLoading ? 'Finalizando Compra...' : 'Finalizar Compra'}
                </Button>
            - CRIANDO UM REDUCER CLEAR E INCLUINDO A VERIFICAÇÃO NO CHECKOUT AO CHEGAR NA PAGINA DE OBRIGADO LIMPAR O CARRINHO 
                Aqui em store/reducers/cart vamos adiconar a ação de limpar, então adicionamos o clear onde vamos buscar o estade de items e colocar em array
                Apos isso vamos importar esse reducers em Checkout e fazer a verificação para quando fianlziar a compra limpar o carrinho
                Entao importamos o reducer em Checkout, importamos o useDispatch e criamos um UseEffect
                No Use Effect vamos usar isSuccess e dispatch como dependencias e dentro dele fazer uma verificação que se isSuccess for true, limpa o carrinho se flase mantem.
                Alem disso, na verificação abaixo que se items.lenght for 0 voltar para home, precisamos editar e incluir que se for isso e isSucces for false ai passa pela função e leva pra home 
                
                store/reducers/cart:
                clear: (state) => {
                    state.items = []
                }

                Chekout/index.tsx:
                useEffect(() => {
                    if (isSuccess) {
                    dispatch(clear())
                    }
                }, [isSuccess, dispatch])

                if (items.length === 0 && !isSuccess) {
                    return <Navigate to={'/'} />
                }
            - AJUSTE NO CARRINHO PARA QUE SE ESTIVER VAZIO APARECE UM TEXTO SE NAO RENDERIZA O CARRINHO
                Aqui vamos fazer uma função itineraria basica que so vai aparecer a ul do carrinho se items.lenght for maior que 0 se nao mostra um texto 
                
                return (
                    <S.CartContainer className={isOpen ? 'is-open' : ''}>
                        <S.Overlay onClick={closeCart} />
                            <S.SideBar>
                                {items.length > 0 ? (                      <<<<<FUNÇÃO DE VERIFICAÇÃO DE TEM ITEM NO CARRINHO, SE TIVER SEGEU PARA UL ABAIXO, SE NAO TIVER VAI PARA O P MAIS ABAIXO
                                <> 
                                    <ul>
                                    {items.map((item) => (
                                        <S.CartItem key={item.id}>
                                        <img src={item.media.thumbnail} alt={item.name} />
                                        <div>
                                            <h3>{item.name}</h3>
                                            <Tag>{item.details.category}</Tag>
                                            <Tag>{item.details.system}</Tag>
                                            <span>{parseToBrl(item.prices.current)}</span>
                                        </div>
                                        <button onClick={() => removeItem(item.id)} type="button" />
                                        </S.CartItem>
                                    ))}
                                    </ul>
                                    <S.Quantity>{items.length} jogo(s) no carrinho</S.Quantity>
                                    <S.Prices>
                                    Total de {parseToBrl(getTotalPrice(items))}{' '}
                                    <span>Em até 6x sem juros</span>
                                    </S.Prices>
                                    <Button
                                    type="button"
                                    title="Clique aqui para continuar com a compra"
                                    onClick={goToCheckout}
                                    >
                                    Continuar com a Compra
                                    </Button>
                                </>
                                ) : (                                                              <<<<<< AQUI ONDE TEMOPS O ELSE
                                <p className="empty-text">
                                    O Carrinho está vazio, adicione pelo menos um produto para
                                    conntinuar com a compra
                                </p>
                        )}
            - INCLUINDO MASCARA EM INPUTS
                Para Inclui mascaras por react precisamos baixar a biblioteca, tanto a para utilização tanto a @types para dev
                npm i --save react-input-mask
                npm i --save-dev @types/react-input-mask
                Apos instalar, vamos inportar no arquivo que vamos utlizar, no caso no checkout
                Apos isso, vamos alterar os inputs que tiverem mascara por InputMask e incluir o tipo 'mask:"Mascara desejada"'
                dentro de mask vamos colocar como queremos que a mascar funcione, por exemplo no input de cpf vamos colocar em mascara mask:"999.999.999-00" assim o valor vai aparecer nessa estilização e assim por diante
                Após isso icluimos o inputmask em cada campo necesario, aqui vou usar apenas o campo cpf como exemplo:
                
                import InputMask from 'react-input-mask'

                <S.InputGroup>
                    <label htmlFor="cpfCardOwner">
                        CPF do Titular do cartão
                    </label>
                    <InputMask                                              <<<< INPUT QUE INSTALAMOS DA BIBLIOTECA REACT-INPUT-MASK
                        id="cpfCardOwner"
                        type="text"
                        name="cpfCardOwner"
                        value={form.values.cpfCardOwner}
                        onChange={form.handleChange}
                        onBlur={form.handleBlur}        
                        className={
                            checkInputHasError('cpfCardOwner') ? 'error' : ''
                        }
                        mask="999.999.999-99"                                 <<<< TIPO QUE INCLUIMOS COM O VALOR QUE QUEREMOS QUE FIQUE A MASCARA                  
                    />
                </S.InputGroup>
            - COLOCANDO LOGO COMO H1
                Aqui vamos colocar a logo como h1 apenas por facilitar pesquisas nos Bowrsers
                então no Header onde esta a Logo, vamos colocar o <img> dentro de um h1 e tirar o line-height do h1 no styles dentro de HeaderBar, porque vem por padrao 

                <Link to={'/'}>
                    <h1>
                    <img src={logo} alt="EPLAY" />
                    </h1>
                </Link>